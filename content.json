{"meta":{"title":"Python绿色通道","subtitle":"a live for changing the world","description":"老司机带你零基础玩Python爬虫，数据分析，机器学习，人工智能","author":"逆水寒","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-01-24T10:02:32.201Z","updated":"2018-01-24T10:02:32.201Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2018-01-24T08:18:51.208Z","updated":"2017-12-31T09:50:25.000Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-01-24T08:18:51.222Z","updated":"2017-12-31T09:50:25.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-01-24T08:18:51.225Z","updated":"2017-12-31T09:50:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-01-24T10:17:22.665Z","updated":"2018-01-24T10:17:22.665Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"吴小龙"},{"title":"标签","date":"2018-01-24T10:42:49.262Z","updated":"2018-01-24T10:42:49.262Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-24T10:35:34.067Z","updated":"2018-01-24T10:35:34.067Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"序言公众号开了好久，也没有给自己写一点介绍的东西，实在说不过去,今天突然觉得要写这点东西，赋予自己一些使命. 经历从事了6年Android开发，所做的项目涉及游戏，社交，云服务，金融，通讯，视频，电商. 其实用的技术也都差不多，用前同事的一句介绍就是UI+网络吧! 说实话技术难点有限,但不同项目有不同项目的坑点，每做一个项目也在尝试不同的解决技巧.好在我的习惯是每做一个项目我都会把所有的东西能封装就封装一下，以便下次直接拿来使用.而这在日后我的工作中发挥了不可估量的作用. 现状最近3年多在创业(自己也投资了一小笔吧)，在公司管理，带团队，产品讨论与研究。最近这几年移动端开发已经进入寒冬状态，而我也进一步发现如果只是在Android方面继续搞下去，前途堪忧.而且就算搞得再好，也只是一个小螺丝钉，做不出自己想要看到的成果，无法满足自己的成就感。我从来就不想把自己当成一个螺丝钉，我觉得一个程序员，最起码应该有一种自我实现的想法. 展望未来当下属于人工智能最为火爆，而Python作为他们主要语言也被炒出了新高度。而且这里面有很多我想做的东西，自我实现空间更大，爬虫，数据分析都能玩。我心里无数次在想我是不是该抓住这波机遇来焕发自己的职业第二春.有了这个想法我就有自己的信仰，也确定了自己想做的事情，我想在Python上做些事情。最近一段时间开始在做了Python方面教程，但我觉得我花的精力还不够，所以会在以后的日子多下点功夫。最近几天和一些朋友搞互推，我发现很多人都喜欢我这个公众号，说明其实很多人想来学Python，但他们找不到比较系统的学习资源，各种资源都很多，没有形成一套体系，有鉴于此，我的公众号定位基本就是这样:Python入门到进阶再到实战,涵盖Python基础，Python爬虫，Python数据分析，Web，大数据，人工智能！.而我认为知识这东西不仅仅是自己的，也更是大家的，我更想在Python这条路上做一个布道者.所以我的公众号教程也是循序渐进，让人人都能学习Python，玩转Python.自我实现! 恩，吹了点牛，但此刻就是这样豪气干云！ Github：https://github.com/pythonchannel微信公众号： Python绿色通道今日头条号： Python绿色通道"},{"title":"Repositories","date":"2018-01-24T10:43:09.584Z","updated":"2018-01-24T10:43:09.584Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Python基础教程2","slug":"Python基础教程1","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:40:34.469Z","comments":true,"path":"2018/01/24/Python基础教程1/","link":"","permalink":"http://yoursite.com/2018/01/24/Python基础教程1/","excerpt":"","text":"1.起步2.变量和简单数据类型1.变量12message = &quot;hello world python&quot;print(message) 2.命名1.命名与使用2.使用变量时避免命名错误3.字符串1.使用方法修改字符串的大小写12345name = &apos;ada lovelace&apos;print(name.title())输出得到：Ada Lovelace title()以首字母大写的方式显示每个单词，即每个单词的首字母都改为大写 123456print(name.upper())print(name.lower())得到：ADA LOVELACEada lovelace #####2.拼接字符串用“+” 来拼接字符串 “\\t,\\n”来空格与换行 3.删除空白 rstrip() 删除末尾的空白 lstrip() 删除头部的空白 strip() 删除字符串两端的空白 123456789msg = &apos; python &apos;print(msg.rstrip())print(msg.lstrip())print(msg.strip())得到pythonpython python 4.使用字符串避免语法错误单引号与单引号一对，双引号与双引号是一对，一般要成对出现，且。 4.使用函数str()避免类型错误12345age = 23msg = &quot;Happy &quot;+str(age)+&quot; rd Birthday&quot; # 必须使用str()否则python识别不了print(msg) 3.列表简介1.列表是什么123bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]print(bicycles) 1.访问列表元素12345print(bicycles[0])得到trek 2.索引从0而不是1开始2.修改，添加和删除元素1.修改列表元素123456789names =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(names)names[0] = &apos;zhangsanfeng&apos;print(names)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsanfeng&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] #####2.列表中添加元素 在列表末尾添加元素 12345678910111213141516names.append(&apos;qianda&apos;)print(names)得到：[&apos;zhangsanfeng&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;qianda&apos;]cars = []cars.append(&apos;honda&apos;)cars.append(&apos;honda2&apos;)cars.append(&apos;honda3&apos;)print(cars)得到[&apos;honda&apos;, &apos;honda2&apos;, &apos;honda3&apos;] 在列表中插入元素 12345cars.insert(0,&apos;honda0&apos;)print(cars)得到：[&apos;honda0&apos;, &apos;honda&apos;, &apos;honda2&apos;, &apos;honda3&apos;] 3.2.3列表中删除元素 使用del语句删除元素 123456nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]del nicks[0]print(nicks)得到：[&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 使用方法pop()删除元素有时候要将元素从列表中删除，并接着使用它的值,方法pop()可删除列表末尾的元素，并让你能够接着使用它。 1234567891011nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)poped_nicks = nicks.pop();print(nicks)print(poped_nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;]zhaoliu 弹出列表中任何位置处的元素 123456789nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)poped_nicks = nicks.pop(0)print(&apos;The first name is &apos;+poped_nicks.title()+&apos;.&apos;)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]The first name is Zhangsan. 如果不确定使用del语句还是pop()方法，有一个简单的标准：如果你要从列表中删除的一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop() 根据值删除元素 123456789nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.remove(&apos;lisi&apos;)print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 3.组织列表1.使用方法sort()对列表进行永久性排序–按字母排序123456789101112131415161718192021nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.sort();print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhangsan&apos;, &apos;zhaoliu&apos;]还可以按字母顺序相反的顺序排列列表元素，只需要向sort()方法传递参数reverse = Truenicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.sort(reverse = True);print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;lisi&apos;] 2.使用方法sorted()对列表进行临时排序–按字母排序12345678910111213141516171819202122232425nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)print(sorted(nicks))print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhangsan&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]还可以相反顺序临时排序nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)print(sorted(nicks,reverse = True))print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;lisi&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 3.倒着打印列表,按元素反转列表排序12345678910111213nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.reverse()print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;wangwu&apos;, &apos;lisi&apos;, &apos;zhangsan&apos;]方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复原来的排列顺序，只需要再次调用reverse() 4.确定列表的长度1234nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(len(nicks))得到：4 ####4.使用列表时避免索引错误注意元素的个数，另外访问最后一个元素时，都可使用索引-1,倒数第2个可以使用索引-2,依次类推 12345nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks[-1])得到：zhaoliu 4.操作列表1.遍历整个列表123456789101112131415nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick) 得到：zhangsanlisiwangwuzhaoliufor cat in cats:for dog in dogsfor item in list_of_items使用单数和复数的式名称可帮助判断代码段处理的是单个列表元素还是整个列表。 1.在for循坏环中执行更多的操作在每条记录中打印一条消息。 12345678910nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) 得到：Zhangsan, welcome to chinaLisi, welcome to chinaWangwu, welcome to chinaZhaoliu, welcome to china 执行多行代码，这里需要注意一下，接下来的代码都是需要缩进的 12345678910111213141516nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;) 得到：Zhangsan, welcome to chinahello,pythonLisi, welcome to chinahello,pythonWangwu, welcome to chinahello,pythonZhaoliu, welcome to chinahello,python #####2.在for循环结束后执行一些操作1234567891011121314151617181920nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;)print(&quot;print all message and print finish!&quot;)得到：Zhangsan, welcome to chinahello,pythonLisi, welcome to chinahello,pythonWangwu, welcome to chinahello,pythonZhaoliu, welcome to chinahello,pythonprint all message and print finish!可以看到最后一条要打印的消息只打印一次，最后一条没有缩进，因此只打印一次 ####2.避免缩进错误 忘记缩进 12345678910nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks:print(nick.title()+&quot;, welcome to china&quot;)得到： File &quot;/Users/liuking/Documents/python/python_learn/test.py&quot;, line 22 print(nick.title()+&quot;, welcome to china&quot;) ^IndentationError: expected an indented block 忘记缩进额外的代码行 1234567891011121314其实想打印两行的消息，结果只打印了一行，print(&quot;hello,python&quot;) 忘记缩进了，结果只是最后一条打印了这条消息nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;)print(&quot;hello,python&quot;)得到：Zhangsan, welcome to chinaLisi, welcome to chinaWangwu, welcome to chinaZhaoliu, welcome to chinahello,python 不必要的缩进 12345678message = &apos;hello python world&apos; print(message)得到： File &quot;/Users/liuking/Documents/python/python_learn/test.py&quot;, line 20 print(message) ^IndentationError: unexpected indent 循环后不必要的缩进 1234567891011121314151617181920212223第三个打印的消息没有缩进，结果每一行都被打印出来了。nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;) print(&quot;print all message and print finish!&quot;) 得到：Zhangsan, welcome to chinahello,pythonprint all message and print finish!Lisi, welcome to chinahello,pythonprint all message and print finish!Wangwu, welcome to chinahello,pythonprint all message and print finish!Zhaoliu, welcome to chinahello,pythonprint all message and print finish! 遗漏了冒号漏掉了冒号，python不知道程序意欲何为。 3.创建数值列表1.使用函数range()函数range()让你能够轻松地生成一系列的数字。 12345678910for value in range(1,5): print(value)得到：1234只打印了1〜4 函数range()从指定的第一个值开始数，并在到达你指定的你第二个值后停止。 #####2.使用range()创建数字列表要创建数字列表，可使用函数list()将range()的结果直接转换为列表，如果将range()作为list()的参数，输出将为一个数字列表。 12345numbers = list(range(1,6))print(numbers)得到：[1, 2, 3, 4, 5] 把10个整数的平方加入列表中，并打印出来 123456789squares = []numbers = range(1,11)for number in numbers: squares.append(number**2)print(squares)得到：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] #####3.对数字列表执行简单的统计计算最小值，最大值，求和 123456789digits = [1,2,3,4,5,6,7,8,9,0]print(min(digits))print(max(digits))print(sum(digits))得到：0945 4.使用列表的一部分1.切片12345678910111213141516nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks[0:3]) 前一个数从0开始，后一个数从1开始数print(nicks[2:3]) 从2开始，截止到第4个元素print(nicks[2:]) 从2开始，没有指定截止数据，直接数到末尾print(nicks[:2]) 没有指定开始，默认从0开始print(nicks[:]) 没有指定开始，也没有指定结束的，直接复制整个列表print(nicks[-2:]) 从倒数第2个开始得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;][&apos;wangwu&apos;][&apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;wangwu&apos;, &apos;zhaoliu&apos;] 2.遍历切片12345678nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks[0:3]: print(nick.title()) 得到：ZhangsanLisiWangwu 3.复制列表—需要特别注意了12345678910111213nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks[:]print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 为了核实我们确实有两个列表，我们可以再添加一下东西 123456789101112131415161718nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks[:]nicks.append(&apos;zhangsanfeng&apos;)nicks_copy.append(&apos;zhangwuji&apos;)print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangwuji&apos;] 如果我们只是简单的nicks赋值给nicks_copy就不能得到两个列表 123456789101112131415161718192021nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks;nicks.append(&apos;zhangsanfeng&apos;)nicks_copy.append(&apos;zhangwuji&apos;)print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;, &apos;zhangwuji&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;, &apos;zhangwuji&apos;]因为nicks和nicks_copy都指向同一个列表，所以都打印出了相同的列表，这里要特别注意 5.元组python将不能修改的值称为不可变的，而不可变的列表被称为元组。有的时候需要创建一系列不可修改的元素，元组可以满足这种需要。 定义元组 元组看起来像列表，但使用圆括号而不是方括号来标识，定义元组后，就可以使用索引来访问其元素。 1234567891011point = (200,50,300,90)print(point[0])print(point[1])print(point[2])print(point[-1])得到：2005030090 遍历元组中的所有值 123456789points = (200,50,300,90)for point in points: print(point) 得到：2005030090 修改元组变量虽然不能修改元组的元素，但可以给存储元组的变量赋值。重新定义整个元组。 12345678910111213141516171819202122print(&quot;original data&quot;)points = (200,50,300,90)for point in points: print(point)print(&quot;\\nmodify data&quot;)points = (1,2,3,4)for point in points: print(point) 得到：original data2005030090modify data1234 5.if语句1.条件测试 检查相等用‘==’ 检查不相等用‘!=’ 检查多个条件 使用and检查多个条件：要检查是否两个条件都为True,可使用关键字and将两个条件测试合而为一；如果每个测试都通过了，整个表达式为就为True,如果至少有一个测试没有通过，则整个表达式为False 使用or检查多个条件:至少有一个条件满足，就能通过整修测试，仅当两个测试都没有通过时，使用or的表达式才为False 检查特定值是否包含在列表中，使用关键字in 1234567request_topping = [&apos;mushrooms&apos;,&apos;onions&apos;,&apos;pineapple&apos;]print(&apos;mushrooms&apos; in request_topping)print(&apos;mush&apos; in request_topping)得到：TrueFalse 检查特定值是否不包含在列表中,使用关键字not in 1234567request_topping = [&apos;mushrooms&apos;,&apos;onions&apos;,&apos;pineapple&apos;]print(&apos;mushrooms&apos; not in request_topping)print(&apos;mush&apos; not in request_topping)得到：FalseTrue ####2.if语句 主要注意的是代码缩进， if if-else if-elif-else 多个elif代码块 省略else代码块 6.字典1.字典的简单使用在Python中字典是一系列的键值对，每一个键都与一个值相关联，与键相关联的值可以是数字，字符串，列表，乃至字典。 访问字典的值 12345alien_0 = &#123;&apos;color&apos;:&apos;green&apos;,&apos;point&apos;:5&#125;print(alien_0[&apos;color&apos;])得到：green 添加键值对 12345678910alien_0 = &#123;&apos;color&apos;:&apos;green&apos;,&apos;point&apos;:5&#125;print(alien_0)alien_0[&apos;x_point&apos;] = 250alien_0[&apos;y_point&apos;] = 100print(alien_0)得到：&#123;&apos;color&apos;: &apos;green&apos;, &apos;point&apos;: 5&#125;&#123;&apos;color&apos;: &apos;green&apos;, &apos;y_point&apos;: 100, &apos;x_point&apos;: 250, &apos;point&apos;: 5&#125; 先创建一个空字典 1234567alien_0 = &#123;&#125;alien_0[&apos;x_point&apos;] = 250alien_0[&apos;y_point&apos;] = 100print(alien_0)得到：&#123;&apos;y_point&apos;: 100, &apos;x_point&apos;: 250&#125; 修改字典中的值 12345678910alien_0 = &#123;&#125;alien_0[&apos;y_point&apos;] = 100print(alien_0)alien_0[&apos;y_point&apos;] = 1000print(alien_0)得到：&#123;&apos;y_point&apos;: 100&#125;&#123;&apos;y_point&apos;: 1000&#125; 删除-键值对 123456789alien_0 = &#123;&apos;color&apos;:&apos;green&apos;,&apos;point&apos;:5&#125;print(alien_0)del alien_0[&apos;point&apos;]print(alien_0)得到：&#123;&apos;color&apos;: &apos;green&apos;, &apos;point&apos;: 5&#125;&#123;&apos;color&apos;: &apos;green&apos;&#125; 2.遍历字典 遍历所有的键值对 1234567891011121314151617181920212223242526values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.items(): print(value)for key,value in values.items(): print(&quot;\\nkey:&quot;+key) print(&quot;value:&quot;+value) 得到：(&apos;1&apos;, &apos;one&apos;)(&apos;3&apos;, &apos;three&apos;)(&apos;2&apos;, &apos;two&apos;)(&apos;4&apos;, &apos;four&apos;)key:1value:onekey:3value:threekey:2value:twokey:4value:four 1.遍历字典中所有的键12345678910values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.keys(): print(value) 得到：1324 2.遍历字典中所有的值12345678910values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.values(): print(value) 得到：onethreetwofour 3.按顺序遍历字典中所有键123456789values = &#123;&apos;first&apos;:&apos;one&apos;,&apos;second&apos;:&apos;two&apos;,&apos;three&apos;:&apos;three&apos;&#125;for value in sorted(values.keys()): print(value) 得到：firstsecondthree 完 7.用户输入和while循环1.函数input()工作原理注意：用户输入只能从终端运行，不能直接通过sublime来运行。 os x系统从终端运行python程序： 1234561. liukingdeMacBook-Pro:~ liuking$ cd Desktop2. liukingdeMacBook-Pro:Desktop liuking$ ls3. input.py4. python3 input.py5. 输出得到结果6. 首先：写一段python 文件 123456789name = input(&quot;Please enter your name: &quot;)print(&quot;Hello,&quot;+name)在终端中运行得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyPlease enter your name: kobe bryantHello,kobe bryantliukingdeMacBook-Pro:Desktop liuking$ 多行输入展示： 多行展示可以用+=来追加字符串。 12345678910111213prompt = &quot;If you tell us who you are,we can personalize the message you see.&quot;prompt += &quot;\\nWhat is your first name?&quot;name = input(prompt)print(&quot;\\n Hello,&quot;+name)得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyIf you tell us who you are,we can personalize the message you see.What is your first name?zhangHello,zhangliukingdeMacBook-Pro:Desktop liuking$ 注意以下几点： 使用int()来获取数值输入 12345678910111213141516height = input(&quot;How tall are you ,in inches? &quot;)height = int(height)if height &gt;= 36: print(&quot;\\n you&apos;re tall enought to ride&quot;)else: print(&quot;\\nyou&apos;ll be able to ride when you&apos;re a little older.&quot;) 得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyHow tall are you ,in inches? 43you&apos;re tall enought to rideliukingdeMacBook-Pro:Desktop liuking$ 注意这里使用了int()把数据类型转换了一下， 求模运算符 求模运算符不会指出一个数是另一个数的多少倍，而只指出余数是多少 12345&gt;&gt;&gt; 5%32&gt;&gt;&gt; 6%20&gt;&gt;&gt; 2.Whil循环1.使用While循环123456789101112131415161718192021number = input(&quot;遍历你输入的数据:&quot;)number = int(number)begin = int(0)while begin &lt;= number: print(begin) begin += 1; 得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.py遍历你输入的数据:10012345678910 2.让用户选择何时退出123456789101112131415161718192021222324promt = &quot;\\nTell me something and I will repeat it back to you:&quot;promt += &quot;\\n Enter &apos;quit&apos; to end the program.&quot;message = &quot;&quot;while message != &apos;quit&apos;: message = input(promt) if message != &apos;quit&apos;: print(message) 终端运行得到：liukingdeMacBook-Pro:DeskTop liuking$ python3 input.pyTell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: NBANBATell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: CBACBATell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: quitliukingdeMacBook-Pro:DeskTop liuking$ 其它使用方式： 使用boolean 标记来判断 使用break退出循环 使用continue 3.使用While循环来处理列表和字典1.在列表之间移动元素12345678910unconfirmed_users = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]confirmed_users = []while unconfirmed_users: current_user = unconfirmed_users.pop() print(&quot;verifying User:&quot;+current_user) confirmed_users.append(current_user)# 显示所有已验证用户 print(“\\n The following users have been confirmed: “)for user in confirmed_users: print(user.title()) 得到：verifying User:threeverifying User:twoverifying User:one The following users have been confirmed:ThreeTwoOne 12#####2.使用用户输入来填充字典 responses = {} 设置一个标志，指出调查是否继续polling_active = True while polling_active: # 提示输入被调查者的名字和回答 name = input(&quot;\\nWhat is your name?&quot;) response = input(&quot;Which mountain would you like to climb someday?&quot;) # 将答案存在字典中 responses[name] = response # 看看是否还有人要参加调查 repeat = input(&quot;would you like to let another person respond?(Y/N)&quot;) if repeat == &apos;N&apos;: polling_active = False 调查结果，显示结果1234567891011121314151617181920print(&quot;\\n----Poll results-----&quot;)for name,response in responses.items(): print(name+&quot; would like to climb &quot;+ response+&quot;.&quot;) 在终端运行得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyWhat is your name?KobeWhich mountain would you like to climb someday?武当山 would you like to let another person respond?(Y/N)YWhat is your name?姚明Which mountain would you like to climb someday?灵山 would you like to let another person respond?(Y/N)N----Poll results-----Kobe would like to climb 武当山.姚明 would like to climb 灵山.liukingdeMacBook-Pro:Desktop liuking$ 完。 1.起步2.变量和简单数据类型1.变量12message = &quot;hello world python&quot;print(message) 2.命名1.命名与使用2.使用变量时避免命名错误3.字符串1.使用方法修改字符串的大小写12345name = &apos;ada lovelace&apos;print(name.title())输出得到：Ada Lovelace title()以首字母大写的方式显示每个单词，即每个单词的首字母都改为大写 123456print(name.upper())print(name.lower())得到：ADA LOVELACEada lovelace 2.拼接字符串用“+” 来拼接字符串 “\\t,\\n”来空格与换行 3.删除空白 rstrip() 删除末尾的空白 lstrip() 删除头部的空白 strip() 删除字符串两端的空白 123456789msg = &apos; python &apos;print(msg.rstrip())print(msg.lstrip())print(msg.strip())得到pythonpython python #####4.使用字符串避免语法错误单引号与单引号一对，双引号与双引号是一对，一般要成对出现，且。 ####4.使用函数str()避免类型错误12345age = 23msg = &quot;Happy &quot;+str(age)+&quot; rd Birthday&quot; # 必须使用str()否则python识别不了print(msg) 3.列表简介1.列表是什么123bicycles = [&apos;trek&apos;,&apos;cannondale&apos;,&apos;redline&apos;,&apos;specialized&apos;]print(bicycles) 1.访问列表元素12345print(bicycles[0])得到trek 2.索引从0而不是1开始2.修改，添加和删除元素1.修改列表元素123456789names =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(names)names[0] = &apos;zhangsanfeng&apos;print(names)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsanfeng&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] #####2.列表中添加元素 在列表末尾添加元素 12345678910111213141516names.append(&apos;qianda&apos;)print(names)得到：[&apos;zhangsanfeng&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;qianda&apos;]cars = []cars.append(&apos;honda&apos;)cars.append(&apos;honda2&apos;)cars.append(&apos;honda3&apos;)print(cars)得到[&apos;honda&apos;, &apos;honda2&apos;, &apos;honda3&apos;] 在列表中插入元素 12345cars.insert(0,&apos;honda0&apos;)print(cars)得到：[&apos;honda0&apos;, &apos;honda&apos;, &apos;honda2&apos;, &apos;honda3&apos;] #####3.2.3列表中删除元素 使用del语句删除元素 123456nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]del nicks[0]print(nicks)得到：[&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 使用方法pop()删除元素有时候要将元素从列表中删除，并接着使用它的值,方法pop()可删除列表末尾的元素，并让你能够接着使用它。 1234567891011nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)poped_nicks = nicks.pop();print(nicks)print(poped_nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;]zhaoliu 弹出列表中任何位置处的元素 123456789nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)poped_nicks = nicks.pop(0)print(&apos;The first name is &apos;+poped_nicks.title()+&apos;.&apos;)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]The first name is Zhangsan. 如果不确定使用del语句还是pop()方法，有一个简单的标准：如果你要从列表中删除的一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop() 根据值删除元素 123456789nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.remove(&apos;lisi&apos;)print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] ####3.组织列表 #####1.使用方法sort()对列表进行永久性排序–按字母排序123456789101112131415161718192021nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.sort();print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhangsan&apos;, &apos;zhaoliu&apos;]还可以按字母顺序相反的顺序排列列表元素，只需要向sort()方法传递参数reverse = Truenicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.sort(reverse = True);print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;lisi&apos;] 2.使用方法sorted()对列表进行临时排序–按字母排序12345678910111213141516171819202122232425nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)print(sorted(nicks))print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhangsan&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]还可以相反顺序临时排序nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)print(sorted(nicks,reverse = True))print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;zhangsan&apos;, &apos;wangwu&apos;, &apos;lisi&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] #####3.倒着打印列表,按元素反转列表排序 12345678910111213nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks)nicks.reverse()print(nicks)得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhaoliu&apos;, &apos;wangwu&apos;, &apos;lisi&apos;, &apos;zhangsan&apos;]方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复原来的排列顺序，只需要再次调用reverse() 4.确定列表的长度1234nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(len(nicks))得到：4 ####4.使用列表时避免索引错误注意元素的个数，另外访问最后一个元素时，都可使用索引-1,倒数第2个可以使用索引-2,依次类推 12345nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks[-1])得到：zhaoliu 4.操作列表1.遍历整个列表123456789101112131415nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick) 得到：zhangsanlisiwangwuzhaoliufor cat in cats:for dog in dogsfor item in list_of_items使用单数和复数的式名称可帮助判断代码段处理的是单个列表元素还是整个列表。 1.在for循坏环中执行更多的操作在每条记录中打印一条消息。 12345678910nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) 得到：Zhangsan, welcome to chinaLisi, welcome to chinaWangwu, welcome to chinaZhaoliu, welcome to china 执行多行代码，这里需要注意一下，接下来的代码都是需要缩进的 12345678910111213141516nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;) 得到：Zhangsan, welcome to chinahello,pythonLisi, welcome to chinahello,pythonWangwu, welcome to chinahello,pythonZhaoliu, welcome to chinahello,python #####2.在for循环结束后执行一些操作1234567891011121314151617181920nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;)print(&quot;print all message and print finish!&quot;)得到：Zhangsan, welcome to chinahello,pythonLisi, welcome to chinahello,pythonWangwu, welcome to chinahello,pythonZhaoliu, welcome to chinahello,pythonprint all message and print finish!可以看到最后一条要打印的消息只打印一次，最后一条没有缩进，因此只打印一次 ####2.避免缩进错误 忘记缩进 12345678910nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks:print(nick.title()+&quot;, welcome to china&quot;)得到： File &quot;/Users/liuking/Documents/python/python_learn/test.py&quot;, line 22 print(nick.title()+&quot;, welcome to china&quot;) ^IndentationError: expected an indented block 忘记缩进额外的代码行 1234567891011121314其实想打印两行的消息，结果只打印了一行，print(&quot;hello,python&quot;) 忘记缩进了，结果只是最后一条打印了这条消息nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;)print(&quot;hello,python&quot;)得到：Zhangsan, welcome to chinaLisi, welcome to chinaWangwu, welcome to chinaZhaoliu, welcome to chinahello,python 不必要的缩进 12345678message = &apos;hello python world&apos; print(message)得到： File &quot;/Users/liuking/Documents/python/python_learn/test.py&quot;, line 20 print(message) ^IndentationError: unexpected indent 循环后不必要的缩进 1234567891011121314151617181920212223第三个打印的消息没有缩进，结果每一行都被打印出来了。nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks: print(nick.title()+&quot;, welcome to china&quot;) print(&quot;hello,python&quot;) print(&quot;print all message and print finish!&quot;) 得到：Zhangsan, welcome to chinahello,pythonprint all message and print finish!Lisi, welcome to chinahello,pythonprint all message and print finish!Wangwu, welcome to chinahello,pythonprint all message and print finish!Zhaoliu, welcome to chinahello,pythonprint all message and print finish! 遗漏了冒号漏掉了冒号，python不知道程序意欲何为。 3.创建数值列表1.使用函数range()函数range()让你能够轻松地生成一系列的数字。 12345678910for value in range(1,5): print(value)得到：1234只打印了1〜4 函数range()从指定的第一个值开始数，并在到达你指定的你第二个值后停止。 #####2.使用range()创建数字列表要创建数字列表，可使用函数list()将range()的结果直接转换为列表，如果将range()作为list()的参数，输出将为一个数字列表。 12345numbers = list(range(1,6))print(numbers)得到：[1, 2, 3, 4, 5] 把10个整数的平方加入列表中，并打印出来 123456789squares = []numbers = range(1,11)for number in numbers: squares.append(number**2)print(squares)得到：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] #####3.对数字列表执行简单的统计计算最小值，最大值，求和 123456789digits = [1,2,3,4,5,6,7,8,9,0]print(min(digits))print(max(digits))print(sum(digits))得到：0945 4.使用列表的一部分1.切片12345678910111213141516nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]print(nicks[0:3]) 前一个数从0开始，后一个数从1开始数print(nicks[2:3]) 从2开始，截止到第4个元素print(nicks[2:]) 从2开始，没有指定截止数据，直接数到末尾print(nicks[:2]) 没有指定开始，默认从0开始print(nicks[:]) 没有指定开始，也没有指定结束的，直接复制整个列表print(nicks[-2:]) 从倒数第2个开始得到：[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;][&apos;wangwu&apos;][&apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;][&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;][&apos;wangwu&apos;, &apos;zhaoliu&apos;] #####2.遍历切片12345678nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]for nick in nicks[0:3]: print(nick.title()) 得到：ZhangsanLisiWangwu 3.复制列表—需要特别注意了12345678910111213nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks[:]print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;] 为了核实我们确实有两个列表，我们可以再添加一下东西 123456789101112131415161718nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks[:]nicks.append(&apos;zhangsanfeng&apos;)nicks_copy.append(&apos;zhangwuji&apos;)print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangwuji&apos;] 如果我们只是简单的nicks赋值给nicks_copy就不能得到两个列表 123456789101112131415161718192021nicks =[&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhaoliu&apos;]nicks_copy = nicks;nicks.append(&apos;zhangsanfeng&apos;)nicks_copy.append(&apos;zhangwuji&apos;)print(&quot;original nicks&quot;)print(nicks)print(&quot;copy nicks&quot;)print(nicks_copy)得到：original nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;, &apos;zhangwuji&apos;]copy nicks[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;, &apos;zhaoliu&apos;, &apos;zhangsanfeng&apos;, &apos;zhangwuji&apos;]因为nicks和nicks_copy都指向同一个列表，所以都打印出了相同的列表，这里要特别注意 ####5.元组python将不能修改的值称为不可变的，而不可变的列表被称为元组。有的时候需要创建一系列不可修改的元素，元组可以满足这种需要。 定义元组 元组看起来像列表，但使用圆括号而不是方括号来标识，定义元组后，就可以使用索引来访问其元素。 1234567891011point = (200,50,300,90)print(point[0])print(point[1])print(point[2])print(point[-1])得到：2005030090 遍历元组中的所有值 123456789points = (200,50,300,90)for point in points: print(point) 得到：2005030090 修改元组变量虽然不能修改元组的元素，但可以给存储元组的变量赋值。重新定义整个元组。 12345678910111213141516171819202122print(&quot;original data&quot;)points = (200,50,300,90)for point in points: print(point)print(&quot;\\nmodify data&quot;)points = (1,2,3,4)for point in points: print(point) 得到：original data2005030090modify data1234 5.if语句1.条件测试 检查相等用‘==’ 检查不相等用‘!=’ 检查多个条件 使用and检查多个条件：要检查是否两个条件都为True,可使用关键字and将两个条件测试合而为一；如果每个测试都通过了，整个表达式为就为True,如果至少有一个测试没有通过，则整个表达式为False 使用or检查多个条件:至少有一个条件满足，就能通过整修测试，仅当两个测试都没有通过时，使用or的表达式才为False 检查特定值是否包含在列表中，使用关键字in 1234567request_topping = [&apos;mushrooms&apos;,&apos;onions&apos;,&apos;pineapple&apos;]print(&apos;mushrooms&apos; in request_topping)print(&apos;mush&apos; in request_topping)得到：TrueFalse 检查特定值是否不包含在列表中,使用关键字not in 1234567request_topping = [&apos;mushrooms&apos;,&apos;onions&apos;,&apos;pineapple&apos;]print(&apos;mushrooms&apos; not in request_topping)print(&apos;mush&apos; not in request_topping)得到：FalseTrue 2.if语句 主要注意的是代码缩进， if if-else if-elif-else 多个elif代码块 省略else代码块 6.字典1.字典的简单使用在Python中字典是一系列的键值对，每一个键都与一个值相关联，与键相关联的值可以是数字，字符串，列表，乃至字典。 访问字典的值 12345alien_0 = &#123;&apos;color&apos;:&apos;green&apos;,&apos;point&apos;:5&#125;print(alien_0[&apos;color&apos;])得到：green 添加键值对 12345678910alien_0 = &#123;&apos;color&apos;:&apos;green&apos;,&apos;point&apos;:5&#125;print(alien_0)alien_0[&apos;x_point&apos;] = 250alien_0[&apos;y_point&apos;] = 100print(alien_0)得到：&#123;&apos;color&apos;: &apos;green&apos;, &apos;point&apos;: 5&#125;&#123;&apos;color&apos;: &apos;green&apos;, &apos;y_point&apos;: 100, &apos;x_point&apos;: 250, &apos;point&apos;: 5&#125; 先创建一个空字典 1234567alien_0 = &#123;&#125;alien_0[&apos;x_point&apos;] = 250alien_0[&apos;y_point&apos;] = 100print(alien_0)得到：&#123;&apos;y_point&apos;: 100, &apos;x_point&apos;: 250&#125; 修改字典中的值 12345678910alien_0 = &#123;&#125;alien_0[&apos;y_point&apos;] = 100print(alien_0)alien_0[&apos;y_point&apos;] = 1000print(alien_0)得到：&#123;&apos;y_point&apos;: 100&#125;&#123;&apos;y_point&apos;: 1000&#125; 删除-键值对 123456789alien_0 = &#123;'color':'green','point':5&#125;print(alien_0)del alien_0['point']print(alien_0)得到：&#123;'color': 'green', 'point': 5&#125;&#123;'color': 'green'&#125; 2.遍历字典 遍历所有的键值对 1234567891011121314151617181920212223242526values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.items(): print(value)for key,value in values.items(): print(&quot;\\nkey:&quot;+key) print(&quot;value:&quot;+value) 得到：(&apos;1&apos;, &apos;one&apos;)(&apos;3&apos;, &apos;three&apos;)(&apos;2&apos;, &apos;two&apos;)(&apos;4&apos;, &apos;four&apos;)key:1value:onekey:3value:threekey:2value:twokey:4value:four 1.遍历字典中所有的键12345678910values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.keys(): print(value) 得到：1324 2.遍历字典中所有的值12345678910values = &#123;&apos;1&apos;:&apos;one&apos;,&apos;2&apos;:&apos;two&apos;,&apos;3&apos;:&apos;three&apos;,&apos;4&apos;:&apos;four&apos;&#125;for value in values.values(): print(value) 得到：onethreetwofour 3.按顺序遍历字典中所有键123456789values = &#123;&apos;first&apos;:&apos;one&apos;,&apos;second&apos;:&apos;two&apos;,&apos;three&apos;:&apos;three&apos;&#125;for value in sorted(values.keys()): print(value) 得到：firstsecondthree 完 7.用户输入和while循环1.函数input()工作原理注意：用户输入只能从终端运行，不能直接通过sublime来运行。 os x系统从终端运行python程序： 1234561. liukingdeMacBook-Pro:~ liuking$ cd Desktop2. liukingdeMacBook-Pro:Desktop liuking$ ls3. input.py4. python3 input.py5. 输出得到结果6. 首先：写一段python 文件 123456789name = input(&quot;Please enter your name: &quot;)print(&quot;Hello,&quot;+name)在终端中运行得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyPlease enter your name: kobe bryantHello,kobe bryantliukingdeMacBook-Pro:Desktop liuking$ 多行输入展示： 多行展示可以用+=来追加字符串。 12345678910111213prompt = &quot;If you tell us who you are,we can personalize the message you see.&quot;prompt += &quot;\\nWhat is your first name?&quot;name = input(prompt)print(&quot;\\n Hello,&quot;+name)得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyIf you tell us who you are,we can personalize the message you see.What is your first name?zhangHello,zhangliukingdeMacBook-Pro:Desktop liuking$ 注意以下几点： 使用int()来获取数值输入 12345678910111213141516height = input(&quot;How tall are you ,in inches? &quot;)height = int(height)if height &gt;= 36: print(&quot;\\n you&apos;re tall enought to ride&quot;)else: print(&quot;\\nyou&apos;ll be able to ride when you&apos;re a little older.&quot;) 得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyHow tall are you ,in inches? 43you&apos;re tall enought to rideliukingdeMacBook-Pro:Desktop liuking$ 注意这里使用了int()把数据类型转换了一下， 求模运算符 求模运算符不会指出一个数是另一个数的多少倍，而只指出余数是多少 12345&gt;&gt;&gt; 5%32&gt;&gt;&gt; 6%20&gt;&gt;&gt; 2.Whil循环1.使用While循环123456789101112131415161718192021number = input(&quot;遍历你输入的数据:&quot;)number = int(number)begin = int(0)while begin &lt;= number: print(begin) begin += 1; 得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.py遍历你输入的数据:10012345678910 2.让用户选择何时退出123456789101112131415161718192021222324promt = &quot;\\nTell me something and I will repeat it back to you:&quot;promt += &quot;\\n Enter &apos;quit&apos; to end the program.&quot;message = &quot;&quot;while message != &apos;quit&apos;: message = input(promt) if message != &apos;quit&apos;: print(message) 终端运行得到：liukingdeMacBook-Pro:DeskTop liuking$ python3 input.pyTell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: NBANBATell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: CBACBATell me something and I will repeat it back to you:Enter &apos;quit&apos; to end the program: quitliukingdeMacBook-Pro:DeskTop liuking$ 其它使用方式： 使用boolean 标记来判断 使用break退出循环 使用continue 3.使用While循环来处理列表和字典1.在列表之间移动元素12345678910111213141516171819202122232425unconfirmed_users = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]confirmed_users = []while unconfirmed_users: current_user = unconfirmed_users.pop() print(&quot;verifying User:&quot;+current_user) confirmed_users.append(current_user)# 显示所有已验证用户```pythonprint(&quot;\\n The following users have been confirmed: &quot;)for user in confirmed_users: print(user.title()) 得到：verifying User:threeverifying User:twoverifying User:oneThe following users have been confirmed: ThreeTwoOne 2.使用用户输入来填充字典1234567891011121314151617181920212223242526272829303132333435363738394041responses = &#123;&#125;# 设置一个标志，指出调查是否继续polling_active = Truewhile polling_active: # 提示输入被调查者的名字和回答 name = input(\"\\nWhat is your name?\") response = input(\"Which mountain would you like to climb someday?\") # 将答案存在字典中 responses[name] = response # 看看是否还有人要参加调查 repeat = input(\"would you like to let another person respond?(Y/N)\") if repeat == 'N': polling_active = False# 调查结果，显示结果```pythonprint(\"\\n----Poll results-----\")for name,response in responses.items(): print(name+\" would like to climb \"+ response+\".\") 在终端运行得到：liukingdeMacBook-Pro:Desktop liuking$ python3 input.pyWhat is your name?KobeWhich mountain would you like to climb someday?武当山 would you like to let another person respond?(Y/N)YWhat is your name?姚明Which mountain would you like to climb someday?灵山 would you like to let another person respond?(Y/N)N----Poll results-----Kobe would like to climb 武当山.姚明 would like to climb 灵山.liukingdeMacBook-Pro:Desktop liuking$ 完。","categories":[],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python基础/"}]},{"title":"Python基础教程2","slug":"Python基础教程2","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:40:27.885Z","comments":true,"path":"2018/01/24/Python基础教程2/","link":"","permalink":"http://yoursite.com/2018/01/24/Python基础教程2/","excerpt":"","text":"8.函数1.定义函数： 使用关键字def来告诉python你要定义一个函数 接着指出函数名：如下面函数名是–greet_user ()是必须带上的，这里可以可以传递一些参数，也可以不传 以:结尾，且与后面所有的缩进构成了函数体 调用函数直接写上函数名，如果有参数记得带上参数 12345678910111213141516171819201. 无参数的函数：def greet_user(): \"\"\"显示简单的函数体\"\"\" print(\"Hello Python\") greet_user()得到：Hello Python2. 有参数的函数：def greet_user(username): \"\"\"显示简单的函数体\"\"\" print(\"Hello Python: \"+username) greet_user('kobe')得到：Hello Python: kobe 1.实参与形参在函数greet_user()中，变量username是一个形参—函数完成其工作所需要的一项信息.在代码greet_user(‘kobe’)中，值’kobe’是一个实参。 2.传递实参1.位置实参需要注意参数的位置 1234567891011121314def describe_pet(animal_type,pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \"+ animal_type + \"'s name is \"+pet_name.title()+\".\")describe_pet('dog','james')describe_pet('dog','iverson')得到：I have a dog.My dog's name is James.I have a dog.My dog's name is Iverson. 2.关键字实参关键字实参是传递给函数的名称-值对,直接在实参中将名称和值关联起来，因此向函数传递实参时不会混淆。与参数顺序无关。 1234567891011def describe_pet(animal_type,pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \"+ animal_type + \"'s name is \"+pet_name.title()+\".\")describe_pet(pet_name = 'kkkk',animal_type = 'cat')得到：I have a cat.My cat's name is Kkkk. 3.默认值编写函数可以给每个形参指定默认值， 12345678910111213141516# 注意已经设置了默认值的参数要放在后面，def describe_pet2(pet_name,animal_type = 'dog'): print(\"\\nI have a \" + animal_type + \".\") print(\"My \"+ animal_type + \"'s name is \"+pet_name.title()+\".\")describe_pet2('kobe')describe_pet2(pet_name = 'james')得到：I have a dog.My dog's name is Kobe.I have a dog.My dog's name is James. 3.返回值1.返回简单值调用返回值的函数时，需要提供一个变量，用于存储返回的值。 12345678910def get_formatted_name(first_name,last_name): \"\"\"返回整洁的姓名\"\"\" full_name = first_name + '-' +last_name return full_name.title()musician = get_formatted_name('kobe','bryant')print(musician)得到：Kobe-Bryant 2. 让实参变成可选的123456789101112131415161718192021def get_formatted_name(first_name,last_name,middle_name= ''): \"\"\"返回整洁的姓名\"\"\" if middle_name: full_name = first_name +'-'+middle_name+'-'+last_name else: full_name = first_name + '-' +last_name return full_name.title()musician = get_formatted_name('kobe','bryant')print(musician)musician = get_formatted_name('kobe','bryant','vboy')print(musician)得到：Kobe-BryantKobe-Vboy-Bryant 3. 返回字典123456789101112131415def build_person(first_name,last_name,age = ''): \"\"\"返回一个字典，其中包含有关一个人的信息\"\"\" person = &#123;'first':first_name,'last':last_name&#125; if age: person['age'] = age pass return person musician = build_person('kobe','bryant',23)print(musician)得到：&#123;'age': 23, 'last': 'bryant', 'first': 'kobe'&#125; 4.结合使用函数和while循环123456789101112131415161718192021222324252627282930313233343536ef get_formatted_name(first_name,last_name,middle_name= ''): \"\"\"返回整洁的姓名\"\"\" if middle_name: full_name = first_name +'-'+middle_name+'-'+last_name else: full_name = first_name + '-' +last_name return full_name.title()while True: print(\"\\nPlease tell me you name:\") first_name = input(\"first Name: \") last_name = input(\"last Name: \") formatted_name = get_formatted_name(first_name,last_name) print(formatted_name) msg = input(\"do you want to exit (Y/N)\") if msg.upper() == 'Y': break 终端运行得到：liukingdeMacBook-Pro:desktop liuking$ python3 input.pyPlease tell me you name:first Name: kobelast Name: bryantKobe-Bryantdo you want to exit (Y/N)nPlease tell me you name:first Name: chris last Name: paulChris-Pauldo you want to exit (Y/N)yliukingdeMacBook-Pro:desktop liuking$ 4. 传递列表1.在函数中修改列表 没有使用函数处理 123456789101112131415161718192021222324252627# 没有使用函数是这样的。\"\"\"将未确认的用户，进行认证。\"\"\"unconfirmed_users = ['one','two','three']confirmed_users = []while unconfirmed_users: \"\"\"处理用户认证操作\"\"\" current_user = unconfirmed_users.pop() print(\"verifying User:\"+current_user) confirmed_users.append(current_user)\"\"\"打印认证用户\"\"\"print(\"\\nThe following users have been confirmed: \")for user in confirmed_users: print(user.title()) 得到：verifying User:threeverifying User:twoverifying User:oneThe following users have been confirmed: ThreeTwoOne 使用函数处理 12345678910111213141516171819202122232425262728293031unconfirmed_users = [&apos;first&apos;,&apos;second&apos;,&apos;third&apos;]confirmed_users = []&quot;&quot;&quot;处理用户认证操作&quot;&quot;&quot;def deal_verify_user(unconfirmed_users,confirmed_users): while unconfirmed_users: &quot;&quot;&quot;处理用户认证操作&quot;&quot;&quot; current_user = unconfirmed_users.pop() print(&quot;verifying User:&quot;+current_user) confirmed_users.append(current_user) def print_verify_user(confirmed_users): for user in confirmed_users: print(user.title())deal_verify_user(unconfirmed_users,confirmed_users)print(&quot;\\nThe following users have been confirmed: &quot;)print_verify_user(confirmed_users)得到：verifying User:thirdverifying User:secondverifying User:firstThe following users have been confirmed: ThirdSecondFirst 上面我们发现得到一样的结果，但使用了函数处理可以做到复用，且逻辑比较清晰，易于扩展。 2.禁止函数修改列表。如果我们像备份之前的数据，我们就不能修改未认证的用户，这个时候我们可以用切片来处理我们的操作了。 123456789101112131415161718192021222324252627282930313233343536373839unconfirmed_users = ['first','second','third']confirmed_users = []\"\"\"处理用户认证操作\"\"\"def deal_verify_user(unconfirmed_users,confirmed_users): while unconfirmed_users: \"\"\"处理用户认证操作\"\"\" current_user = unconfirmed_users.pop() print(\"verifying User:\"+current_user) confirmed_users.append(current_user) def print_user(confirmed_users): for user in confirmed_users: print(user.title())\"\"\"这里我们将列表的副本传给函数，列表的原始数据不会被修改\"\"\"deal_verify_user(unconfirmed_users[:],confirmed_users)print(\"\\nThe following users have been confirmed: \")print_user(confirmed_users)print(\"\\n展示原始数据: \")print_user(unconfirmed_users)得到：verifying User:thirdverifying User:secondverifying User:firstThe following users have been confirmed: ThirdSecondFirst展示原始数据: FirstSecondThird 5.传递任意数量的实参。有的时候我们不知道函数需要接受多少个实参，python允许函数从调用语句中收集任意数量的实参。 12345678910111213141516171819“”“这里*toppons指定了一个空元组，将收到的所有值都封装在这个这元组中。”“”def make_pizza(*toppons): \"\"\"打印顾客点的所有配料\"\"\" print(\"\\nMaking a pizza with the following toppings\") for top in toppons: print(\"- \"+top.title())make_pizza('pepperoni')make_pizza('pepperoni','green peppers','extra cheese')得到：Making a pizza with the following toppings- PepperoniMaking a pizza with the following toppings- Pepperoni- Green Peppers- Extra Cheese 1.结合使用位置实参和任意数量实参，如果要让函数接受不同类型的实参，必须在函数定义中接纳任意数量实参的形参放在最后。python先匹配位置实参和关键字实参，再匹配任意实参，所以这里我们把make_pizza(size,*toppons),位置实参在前，任意实参在后。 123456789101112131415161718def make_pizza(size,*toppons): &quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot; print(&quot;\\nMaking a &quot; + str(size) +&quot;-inch pizza with the following toppings&quot;) for top in toppons: print(&quot;- &quot;+top.title())make_pizza(18,&apos;pepperoni&apos;)make_pizza(33,&apos;pepperoni&apos;,&apos;green peppers&apos;,&apos;extra cheese&apos;)得到：Making a 18-inch pizza with the following toppings- PepperoniMaking a 33-inch pizza with the following toppings- Pepperoni- Green Peppers- Extra Cheese 2.使用任意数量的关键字实参。有时候需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量键值对—调用语句提供了多少就接爱多少。 注意：使用任意数量的关键字实参需要使用**声明 12345678910111213141516def build_profile(first,last,**user_info): \"\"\"创建一个字典\"\"\" profile = &#123;&#125; profile['first_name'] = first profile['last_name'] = last for key,value in user_info.items(): profile[key] = value return profileinfo = build_profile('Kobe','bryant',like = 'ball',age = 35)print(info)得到：&#123;'first_name': 'Kobe', 'last_name': 'bryant', 'age': 35, 'like': 'ball'&#125; 6.将函数存储在模块中。函数的优点之一是，使用它们可将代码块与主程序分离，通过给函数指定描述性名称，可让主程序容易得多。还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块代码。 通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点入在程序的高层逻辑上，还能让你在众多不同的程序中重用函数。将函数存储在独立文件后，可与其它程序员共享这些文件而不是整个程序。知道如何导入函数，还能让你使用其它程序员编写的函数库。 1.导入整个模块。使用import语句导入了名为module_name.py的整个模块，就可使用下面的语法来使用其中任何一个函数。 module_name.function_name() 下面我们创建一个input.py文件。 12345def make_pizza(size,*toppons): \"\"\"打印顾客点的所有配料\"\"\" print(\"\\nMaking a \" + str(size) +\"-inch pizza with the following toppings\") for top in toppons: print(\"- \"+top.title()) 再创建一个test_input.py文件 1234567891011121314import inputinput.make_pizza(18,'pepperoni')input.make_pizza(33,'pepperoni','green peppers','extra cheese')得到：Making a 18-inch pizza with the following toppings- PepperoniMaking a 33-inch pizza with the following toppings- Pepperoni- Green Peppers- Extra Cheese 上面我们使用import 导入input文件。然后使用文件名input，再调用函数。 2.导入特定的函数。 还可以导入模块中特写的函数，这种导入方法的语法如下：from module_name import function_name 通过用逗号来分隔函数名，可根据需要从模块中导入任意数量的函数：from module_name import function_0,function_1,function_2 对于只想导入要使用的函数，代码将类似于下面这样： 使用这种语法，调用函数时就无需使用句点，由于我们在import语句中显示地导入了函数make_pizza，因此调用它时只需要指定其名称。 123456from input import make_pizzamake_pizza(18,'pepperoni')make_pizza(33,'pepperoni','green peppers','extra cheese')可以得到同样的效果。 3.使用as给函数指定别名。有的时候要导入的函数名称可能与程序中现有的名称冲突，或者函数名称太长，可指定简短而独一无二的别名—函数的另一个名称，类似于外号。 指定别名的通用语法是：from module_name import function_name as fn 下面我们可以把上面代码修改一下： 1234from input import make_pizza as mpmp(18,'pepperoni')mp(33,'pepperoni','green peppers','extra cheese') 4.使用as给模块指定别名还可以给模块指定别名。给模块指定别名通用语法如下：import module_name as mn代码如下： 1234import input as putput.make_pizza(18,'pepperoni')put.make_pizza(33,'pepperoni','green peppers','extra cheese') #####5.导入模块中所有的函数使用星号（） 运算符可以让Python导入模块中所有的函数：`from module_name import ` 首先创建有两个函数的文件： 123456789101112def make_pizza(size,*toppons): \"\"\"打印顾客点的所有配料\"\"\" print(\"\\nMaking a \" + str(size) +\"-inch pizza with the following toppings\") for top in toppons: print(\"- \"+top.title())def make_KFC(size,*toppons): \"\"\"打印顾客点的所有配料\"\"\" print(\"\\nMaking a \" + str(size) +\"-inch KFC with the following toppings\") for top in toppons: print(\"- \"+top.title()) 再调用： 12345678910111213141516from input import *make_pizza(33,'pepperoni','green peppers','extra cheese')make_KFC(33,'pepperoni','green peppers','extra cheese')得到：Making a 33-inch pizza with the following toppings- Pepperoni- Green Peppers- Extra CheeseMaking a 33-inch KFC with the following toppings- Pepperoni- Green Peppers- Extra Cheese 注意：import语句中星号让Python将模块中每个函数都复制到这个程序文件中，由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。但使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你项目的中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。 最佳做法：要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易理解和阅读。 ####7.函数编写指南编写函数时，需要牢记几个细节：应给函数指定描述性名称，且只在其中使用小写字母和下划线，描述性名称可帮助你和别人明白代码想要什么，给模块命名时也应按上述约定。给形参指定默认值时，等号两边不要有空格。 def function_name(parameter_0,parameter_1=&#39;devault value&#39;) 对于函数调用中的关键字实参， function_name(value_0,parameter=&#39;value&#39;) 完 9.类所有的面向对象编辑思想都是一样的，所以这一篇对于是程序员的你一定是非常简单的. 9.1 创建和使用类123456789101112131415161718class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def update_odometer(self, mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\"you can't roll back an odometer!\") 这里面我就创建了一个一个Car类,不要问我为什么这么写，这就是约定。代码说明def __init__(self, make, model, year): 这是一个特殊的函数，使用两个下划线标记主要是为了跟其它的普通函数区分开来。 在java里这个叫构造函数 里面有带了几个参数来填充属性，还可以添加默认参数，里面我添加了一个odometer_reading这个属性 这里面我添加了两个方法get_descriptive_name 和 update_odometer 这里面必须传入self，这是对自身的一种引用，另外还可以在后面添加若干参数。 使用类:123456789101112131415byd = Car('byd','byd tang','2017') #实例化Car类str1 = byd.get_descriptive_name() # 调用类的方法print(str1.title())得到结果2017 Byd Byd Tang再调用一个带参数的方法byd.update_odometer(100);print('move '+str(byd.odometer_reading)+' miles')得到结果：move 100 miles 9.2 继承直接在Car这个文件里再写一个子类，电动车类： 12345678910111213141516171819202122232425class ElectriCar(Car): #继承Car类 \"\"\"电动汽车独特之处\"\"\" def __init__(self, make, model, year, battery_size=100): \"\"\"初始化父类的属性\"\"\" super().__init__(make, model, year) #这里继承父类的属性 和java里的super方法一样 self.battery_size = battery_size # 子类有自己的属性 def descript_batter(self): print(\"This car has a \" + str(self.battery_size) + \" kwh battery.\") def fill_gas_tank(self): print(\"i hava a battery\")my_tesla = ElectriCar('tesla', 'model s', '2016')print(my_tesla.get_descriptive_name()) #引用父类的描述方法print(my_tesla.fill_gas_tank()) #重写子类的电池方法得到结果：2016 Tesla Model Si hava a battery 代码说明 在类名称后的括号中写上父类 在init方法中使用super方法来继承父类的属性 子类自动拥有父类全部的方法 子类可以重写父类方法，但方法名一定要写父类一样. 9.3 导入类9.4 Python标准库10.文件和异常3.异常异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误信息，而不是令用户迷惑的traceback. #####1.处理ZeroDivisionError异常。 1print(5/0) 2.使用try-except代码块当你认为可能发生了错误时，可编写一个try-except代码块来处理可能引发的异常。 处理ZeroDivisionError异常的try-except代码块类似于下面这样： 1234try: print(5/0)except Exception, e: print(\"You can't divide by zero!\") 如果程序出现异常，就执行print(“You can’t divide by zero!”),不再是traceback: 3.使用异常避免崩溃发生错误时，如果程序还有工作没有完成，妥善处理错误就尤其重要。这种情况经常会现出现在要求用户提供输入的程序中；如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。 下面来一个只执行除法的简单计算器： 123456789101112131415161718192021222324252627282930313233print(\"Give me two numbers, and I'll divide them.\")print(\"Enter 'q' to quit. \")while True: first_number = input(\"\\nFirst number: \") if first_number == 'q': break; second_number = input(\"\\nSecond number: \") if second_number == 'q': break; answer = int(first_number)/int(second_number) print(answer) 得到：liukingdeMacBook-Pro:desktop liuking$ python3 input.pyGive me two numbers, and I'll divide them.Enter 'q' to quit. First number: 4Second number: 22.0First number: 4Second number: gTraceback (most recent call last): File \"input.py\", line 244, in &lt;module&gt; answer = int(first_number)/int(second_number)ValueError: invalid literal for int() with base 10: 'g'liukingdeMacBook-Pro:desktop liuking$ 4. else代码块。通过将可能引发错误的代码放在try-except代码块中，可提高这个程序抵御错误的能力，错误是是执行除法运算的代码行导致的，因此我们需要将它放到try-except代码块中。依赖于try代码块成功执行的代码都放到else代码块中： 123456789101112131415161718192021222324252627282930313233343536print(\"Give me two numbers, and I'll divide them.\")print(\"Enter 'q' to quit. \")while True: first_number = input(\"\\nFirst number: \") if first_number == 'q': break; second_number = input(\"\\nSecond number: \") if second_number == 'q': break; try: answer = int(first_number)/int(second_number) except Exception: print(\"you can't divide by 0!\") else: print(answer)得到：liukingdeMacBook-Pro:desktop liuking$ python3 input.pyGive me two numbers, and I'll divide them.Enter 'q' to quit. First number: 5Second number: 31.6666666666666667First number: 5Second number: 0you can't divide by 0!First number: 发现异常也能友好的提示给用户。 try-except-else代码块的工作原理大致如下：python尝试执行try代码块中的代码;只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的代码，这些代码应该放在else代码块中。except代码块告诉python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。 通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或者缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。 #####5. 处理FileNotFoundError异常。 4.存储数据一般都是使用模块json来存储数据。 1.使用json.dump()写入数据和json.load()加载数据。使用json.dump()来存储(写入)数据 12345import jsonnumbers = [2,3,5,7,9,22,44]file_name = 'numbers.json'with open(file_name,'w') as f_obj: json.dump(numbers,f_obj) 我们先要导入模块json，再执行，最后可以打开numbers.json文件，看到其内容与python中一样。 再使用json.load()读取numbers.json文件： 12345678910import jsonfile_name = &apos;numbers.json&apos;with open(file_name) as f_obj: numbers = json.load(f_obj)print(numbers)得到：[2, 3, 5, 7, 9, 22, 44] 与我们期望的一致。 11.测试代码1.测试1.单元测试和测试用例Python标准库中的模块unitest提供了代码测试工具。单元测试用于测试函数的某个方面是否有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。 2.可通过的测试要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试。 首先我们来写一个方法： 1234def get_formatted_name(first,last): \"\"\"Generate a neatly formatted full name.\"\"\" full_name = first + ' ' + last return full_name.title() 再写一个测试用例 1234567891011121314151617181920import unittestfrom name_function import get_formatted_nameclass NameTestCase(unittest.TestCase): \"\"\"测试name_function.py\"\"\" def test_first_last_name(self): \"\"\"能够正确地处理Janis Joplin这样的姓名吗？\"\"\" formatted_name = get_formatted_name('janis','joplin') self.assertEqual(formatted_name,'Janis Joplin')unittest.main()得到：.----------------------------------------------------------------------Ran 1 test in 0.000sOK 首先我们导入了模块unittest和要测试的函数get_formatted_name() 我们创建了一个NameTestCase的类用于包含一系列针对get_formatted_name()的单元测试。可以随便给这个类命名，但最好让它看起来要与测试的函数相关，并包含字样Test。这个类必须继承unittest.TestCase类 我们使用了unittest类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。 第1行的句点表明有一个测试通过了，接下来的一行指出Python运行了一个测试，消耗的时候不到0.01s，最后的OK表明该测试用例中的所有单元测试都通过了。 测试方法名为test-first-last-name(),方法名必须以test_开头，这样它才会在我们测试的时候自动运行。这个方法名清楚地指出了它测试的是get_formatted_name()的那个行为，这样如果该测试未通过，我们就会马上知道受影响的是那种类型的姓名。在TestCase类中使用很长的方法名是可以的，这些方法的名称必须是描述性的这才能让你明白测试未通过的时的输出，这些方法由python自动调用，你根本不用编写调用它们的代码。 3.不能通过的测试这里我们给出一个不能通过测试的案例 12345678910111213141516171819202122def get_formatted_name(first,middle,last): \"\"\"Generate a neatly formatted full name.\"\"\" full_name = first + ' ' + middle + ' ' + last return full_name.title() 再运行一下：E======================================================================ERROR: test_first_last_name (__main__.NameTestCase)能够正确地处理Janis Joplin这样的姓名吗？----------------------------------------------------------------------Traceback (most recent call last): File \"/Users/liuking/Desktop/test_name_function.py\", line 11, in test_first_last_name formatted_name = get_formatted_name('janis','joplin')TypeError: get_formatted_name() takes exactly 3 arguments (2 given)----------------------------------------------------------------------Ran 1 test in 0.000sFAILED (errors=1)[Finished in 0.1s with exit code 1] 首先指出测试用例中有一个单元测试导致了错误 NameTestCase中的test_first_last_name()导致了错误,知道那个测试没有通过至关重要。 我们看到了Traceback 4. 测试未通过时怎么办测试未通过时怎么办？如果检查的条件没错，测试通过了意味着函数的行为是对的，而测试未通过意味着你编写的新代码有错，因此测试未通过时，不要修改测试，而应修复导致测试不能通过的代码：检查刚对函数所做的修改，找到导致函数行为不符合预期的修改。 把刚才的函数代码稍作修改： 12345678910111213141516def get_formatted_name(first,last,middle = &apos;&apos;): &quot;&quot;&quot;Generate a neatly formatted full name.&quot;&quot;&quot; if middle: full_name = first + &apos; &apos; + middle + &apos; &apos; + last else: full_name = first + &apos; &apos; + last return full_name.title() 得到：.----------------------------------------------------------------------Ran 1 test in 0.000sOK[Finished in 0.1s] 又能正确通过测试。 #####5.添加新测试我们为NamesTestCase再添加一个方法： 123456789101112131415161718192021222324252627# -*- coding: utf8 -*-import unittestfrom name_function import get_formatted_nameclass NameTestCase(unittest.TestCase): &quot;&quot;&quot;测试name_function.py&quot;&quot;&quot; def test_first_last_name(self): &quot;&quot;&quot;能够正确地处理Janis Joplin这样的姓名吗？&quot;&quot;&quot; formatted_name = get_formatted_name(&apos;janis&apos;,&apos;joplin&apos;) self.assertEqual(formatted_name,&apos;Janis Joplin&apos;) def test_first_last_middle_name(self): &quot;&quot;&quot;能够正确地处理Janis Joplin Kobe这样的姓名吗？&quot;&quot;&quot; formatted_name = get_formatted_name(&apos;janis&apos;,&apos;Kobe&apos;,&apos;joplin&apos;) self.assertEqual(formatted_name,&apos;Janis Joplin Kobe&apos;)unittest.main()得到：..----------------------------------------------------------------------Ran 2 tests in 0.000sOK[Finished in 0.1s] ####2.测试类 #####1.各种断言方法常用的断言方法，使用这些方法可核实返回的值等于或不等于预期的值，返回的值为True或False,返回的值在列表中或者不在列表中。只能在继承unittest.TestCase的类中使用这些方法 unittest Module中的断言方法 方法 用途 assertEqual(a,b) 核实 a ==b assertNotEqual(a,b) 核实 a !=b assertTrue(x) 核实x为True assertFalse(x) 核实x为False assertIn(item,list) 核实item在list中 assertNotIn(item,list) 核实item不在list中 2.一个要测试的类类的测试与函数的测试相似–你所做的大部分工作都是测试类中方法的行为，但存在一些不同之处， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding: utf8 -*-class AnonymousSurvey(): \"\"\"收集匿名调查问卷的答案\"\"\" def __init__(self, question): self.question = question self.responses = [] def show_question(self): \"\"\"显示调查问卷\"\"\" print(self.question) def store_response(self,new_response): \"\"\"存储单份调查问卷\"\"\" self.responses.append(new_response); def show_results(self): \"\"\"显示收集到的所有答案\"\"\" print(\"Survey Results:\") for response in self.responses: print('- '+response) ------------------------------------------------------------------------------------------ from survey import AnonymousSurvey#定义一人问题，并创建一个表示调查的AnonymousSurvey对象question = \"What language did you first learn to speak?\"my_survey = AnonymousSurvey(question)my_survey.show_question()print(\"Enter 'q' at any time to quit.\\n\")while True: response = input(\"language: \") if response == 'q': break my_survey.store_response(response)#显示调查结果：print(\"\\nThank you to everyone who participated in the survey?\")my_survey.show_results()运行得到：在终端运行得到：What language did you first learn to speak?Enter 'q' at any time to quit.language: englishlanguage: chineselanguage: japaneselanguage: qThank you to everyone who participated in the survey?Survey Results:- english- chinese- japanese 3.测试AnonymousSurvey类下面来编写一个测试，对AnonymousSurvey类的行为的一个方面进行验证：如果用户面对调查问题时只提供一个答案，这个答案也能被妥善保存，为此我们将在这个答案被保存后，用方法assertIn()来核实包含在答案列表中： 1234567891011121314151617181920212223import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): \"\"\"docstring for ClassName\"\"\" def test_store_single_response(self): question = \"what language did you first learn to speak?\" my_survey = AnonymousSurvey(question) my_survey.store_response('english') self.assertIn('english',my_survey.responses) unittest.main()运行得到：.----------------------------------------------------------------------Ran 1 test in 0.000sOK[Finished in 0.1s] 这里我们首先导入了模块unittest以及要测试的类AnonymousSurvey，它也继承于unittest.TestCase第一个测试方法验证调查问题的单个答案被存储后，会包含在调查结果列表中。 只能收集一个答案的调查用途不大，我们来核实用户提供的三个答案，也将它们存储。 12345678910111213141516171819202122232425262728293031import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): \"\"\"docstring for ClassName\"\"\" def test_store_single_response(self): question = \"what language did you first learn to speak?\" my_survey = AnonymousSurvey(question) my_survey.store_response('english') self.assertIn('english',my_survey.responses) def test_store_three_responses(self): question = \"what language did you first learn to speak?\" my_survey = AnonymousSurvey(question) responses = ['english','chinese','japanese'] for response in responses: my_survey.store_response(response) for response in responses: self.assertIn(response,my_survey.responses) unittest.main() 运行得到：..----------------------------------------------------------------------Ran 2 tests in 0.000sOK[Finished in 0.1s] 4. 方法setUp()在unittest.TestCase类包含方法setUp(),让我们只需要创建这些对象一次，并在每个测试方法中使用他们，如果你在TestCase类中包含了方法setUp()，Python将先运行它，再运行各个以test_打头的方法，这样在我们编写的每个测试方法中都可使用方法setUp()中创建的对象。 123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf8 -*-import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): def setUp(self): \"\"\"创建一个调查对象和一组答案，供使用的测试方法使用。\"\"\" question = \"What language did you first learn to speak?\" self.my_survey = AnonymousSurvey(question) self.responses = ['chinese','english','japanese'] \"\"\"docstring for ClassName\"\"\" def test_store_single_response(self): self.my_survey.store_response(self.responses[0]) self.assertIn(self.responses[0],self.my_survey.responses) def test_store_three_responses(self): for response in self.responses: self.my_survey.store_response(response) for response in self.responses: self.assertIn(response,self.my_survey.responses) unittest.main()运行得到：..----------------------------------------------------------------------Ran 2 tests in 0.000sOK[Finished in 0.1s] 方法setUp()让测试方法编写起来更容易，可在setUp()方法中创建一系列并设置他们的属性，再在测试方法中直接使用这些实例，相比于在每个测试方法中都都创建并设置其属性，这要容易得多。","categories":[],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python基础/"}]},{"title":"Pyhyon爬虫牛刀小试","slug":"爬虫牛刀小试","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:41:07.732Z","comments":true,"path":"2018/01/24/爬虫牛刀小试/","link":"","permalink":"http://yoursite.com/2018/01/24/爬虫牛刀小试/","excerpt":"","text":"爬虫的抓取方式有好几种，正则表达式，Lxml(xpath)与Beautiful,我在网上查了一下资料，了解到三者之间的使用难度与性能 三种爬虫方式的对比。 抓取方式 性能 使用难度 正则表达式 快 困难 Lxml 快 简单 BeautifulSoup 慢 简单 这样一比较我我选择了Lxml(xpath)的方式了，虽然有三种方式，但肯定是要选择最好的方式来爬虫，这个道理大家都懂，另外有兴趣的朋友也可以去了解另外两种爬虫方式！ 好了现在来讲讲xpath 由于Xpath属于lxml模块，所以首先需要安装lxml库，老办法直接在file–&gt;setting—project interpreter 一键添加lxml库。 ####xpath简单用法 from lxml import etree s=etree.HTML(源码) #将源码转化为能被XPath匹配的格式 s.xpath(xpath表达式) #返回为一列表, ####基础语法： // 双斜杠 定位根节点，会对全文进行扫描，在文档中选取所有符合条件的内容，以列表的形式返回。 / 单斜杠 寻找当前标签路径的下一层路径标签或者对当前路标签内容进行操作 /text() 获取当前路径下的文本内容 /@xxxx 提取当前路径下标签的属性值 | 可选符 使用|可选取若干个路径 如//p | //div 即在当前路径下选取所有符合条件的p标签和div标签。 . 点 用来选取当前节点 .. 双点 选取当前节点的父节点 学以致用，方能让我们能快速掌握xpath语法功能。 我们这次需要爬取豆瓣音乐前250条 打开豆瓣音乐：https://music.douban.com/top250 ###获取单条数据 #####1.获取音乐标题 右键弹出菜单栏 Copy==&gt; Copy Xpath 这里我们想获取音乐标题，音乐标题的xpath是：xpath://*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/a 1234567891011# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)title = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/a')print title 运行代码：居然是空的。！！！这里需要注意一下，浏览器复制的xpath只能作参考，因为浏览器经常会在自己里面增加多余的tbody标签，我们需要手动把这个标签删除删除中间的/tbody后,是这样的，title = s.xpath(&#39;//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tr/td[2]/div/a&#39;)然后我们再运行代码。得到：&lt;Element a at 0x53d26c8&gt; 说明标题被获取到了。因为要获取标题文本，所以xpath表达式要追加/text()title = s.xpath(&#39;//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()&#39;)#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text() 又因为这个s.xpath返回的是一个集合，且集合中只有一个元素所以我再追加一个[0]新的表达式：title = s.xpath(&#39;//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()&#39;)[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text(),再追加[0] 重新运行得到结果：We Sing. We Dance. We Steal Things.正是我们想要的标题。 #####2.获取音乐评分与评价人数 老办法，先用右键copy评分的xpath ://*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/div/span[2]复制评价人数的xpath://*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/div/span[3]/text() 同样的我们要把tbody去掉，然后重新运行代码：12345678910111213# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)title = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()score = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[2]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()numbers = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[3]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()print title,score,numbers 得到： We Sing. We Dance. We Steal Things. 9.1 ( 100395人评价 ) #####3.获取音乐链接copy标题的xpath，：//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/a 想获取音乐连接href这里需要，获取这个标签属于,/@xxx可以提取当前路径标签下的属性值//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div/a/@href 代码：1234567891011121314# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)href = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/@href')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()title = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()score = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[2]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()numbers = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[3]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()print href,title,score,numbers 运行代码得到：123456https://music.douban.com/subject/2995812/ We Sing. We Dance. We Steal Things. 9.1 ( 100395人评价 ) #####5.获取图片地址：找到图片，复制他的xpath地址：//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[1]/a/img 运行代码： 123456789101112131415# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)href = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/@href')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()title = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()score = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[2]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()numbers = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[3]/text()')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()imgpath = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[1]/a/img/@src')[0]#因为要获取文本，所以我需要这个当前路径下的文本，所以使用/text()print href,title,score,numbers,imgpath 老套路：得到结果:1234567https://music.douban.com/subject/2995812/ We Sing. We Dance. We Steal Things. 9.1 ( 100395人评价 ) https://img3.doubanio.com/spic/s2967252.jpg 但是这只是获取了一条数据，如果获取多条数据呢？ ###获取多条数据 我们再看第二条数据，第三条数据,第四条数据得到他们的xpath:123456789101112131415# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)title = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()title2 = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[2]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()title3 = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[3]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()title4 = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table[4]/tr/td[2]/div/a/text()')[0]#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()print title,title2,title3,title4 得到： We Sing. We Dance. We Steal Things. Viva La Vida 华丽的冒险 范特西 对比他们的xpath，发现只有table序号不一样，我们可以就去掉序号，得到通用的xpath信息：运行代码： 12345678910111213# coding:utf-8from lxml import etreeimport requestsurl = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)titles = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table/tr/td[2]/div/a/text()')#因为要获取标题，所以我需要这个当前路径下的文本，所以使用/text()for title in titles: print title.strip() 得到：1234567891011121314151617181920212223242526272829303132333435363738394041We Sing. We Dance. We Steal Things.Viva La Vida华丽的冒险范特西後。青春期的詩是时候LenkaStart from Here旅行的意义太阳Once (Soundtrack)Not Going AnywhereAmerican IdiotOK無與倫比的美麗亲爱的...我还不知道城市OWake Me Up When September Ends叶惠美七里香21My Life Will...寓言你在烦恼什么 其它的信息如：链接地址，评分，评价人数都可以用同样的办法来获取，现在我同时获取多条数据，因为每页数据是25条，所以：完整代码如下： 123456789101112131415161718# coding:utf-8from lxml import etreeimport requestsurl = &apos;https://music.douban.com/top250&apos;html = requests.get(url).texts = etree.HTML(html)hrefs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/a/@href&apos;)titles = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/a/text()&apos;)scores = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/div/span[2]/text()&apos;)numbers = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/div/span[3]/text()&apos;)imgs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[1]/a/img/@src&apos;)for i in range(25): print hrefs[i],titles[i],scores[i],numbers[i],imgs[i] 得到：一大批数据了，我就不展示了。有兴趣可以直接copy代码运行.,注意你得装上lxml与requests库. 我们也发现了问题每一个xpath路径特别长，能不能精简一下呢？ #####5. 精简一下xpath路径 12345hrefs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/a/@href&apos;)titles = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/a/text()&apos;)scores = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/div/span[2]/text()&apos;)numbers = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[2]/div/div/span[3]/text()&apos;)imgs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table/tr/td[1]/a/img/@src&apos;) 观察发现获取几个关键字段的xpath前缀都是 //*[@id=&quot;content&quot;]/div/div[1]/div/table/tr 那我能不能把这些东西提出来呢，让后面的不同的自己去追加，另外这样写也不用管每个页面到底有多少条数据，只管查就行了。所以代码做了一下精简。 12345678910111213url = 'https://music.douban.com/top250'html = requests.get(url).texts = etree.HTML(html)trs = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table/tr') #先提取tr之前的节点集合for tr in trs: #遍历tr href = tr.xpath('./td[2]/div/a/@href')[0] #注意新节点是tr下的节点 title = tr.xpath('./td[2]/div/a/text()')[0] score = tr.xpath('./td[2]/div/div/span[2]/text()')[0] number = tr.xpath('./td[2]/div/div/span[3]/text()')[0] img = tr.xpath('./td[1]/a/img/@src')[0] print href,title,score,number,img 得到的结果和之前是一样的。 但是，但是，这只是一个页面的数据，我现在想爬取多个页面的数据，怎么办呢？ ###获取个多页面数据. 观察一下翻页路径：https://music.douban.com/top250?start=0https://music.douban.com/top250?start=25https://music.douban.com/top250?start=50 有没有发现页面只是后面start参数发生了改变，且增长为每次25，并且250条数据正好是10页。所以我可以遍历这个页面。代码：123for i in range(10):url = 'https://music.douban.com/top250?start=&#123;&#125;'.format(i*25)print url 得到： 12345678910https://music.douban.com/top250?start=0https://music.douban.com/top250?start=25https://music.douban.com/top250?start=50https://music.douban.com/top250?start=75https://music.douban.com/top250?start=100https://music.douban.com/top250?start=125https://music.douban.com/top250?start=150https://music.douban.com/top250?start=175https://music.douban.com/top250?start=200https://music.douban.com/top250?start=225 正是自己要的结果。 好了最后我们把代码拼装在一起，并注意每个方法的用途。 ###完整代码 12345678910111213141516171819202122232425262728# coding:utf-8from lxml import etreeimport requests#获取页面地址def getUrl(): for i in range(10): url = 'https://music.douban.com/top250?start=&#123;&#125;'.format(i*25) scrapyPage(url)#爬取每页数据def scrapyPage(url): html = requests.get(url).text s = etree.HTML(html) trs = s.xpath('//*[@id=\"content\"]/div/div[1]/div/table/tr') for tr in trs: href = tr.xpath('./td[2]/div/a/@href')[0] title = tr.xpath('./td[2]/div/a/text()')[0] score = tr.xpath('./td[2]/div/div/span[2]/text()')[0] number = tr.xpath('./td[2]/div/div/span[3]/text()')[0] img = tr.xpath('./td[1]/a/img/@src')[0] print href, title, score, number, imgif '__main__': getUrl()","categories":[],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python爬虫/"}]},{"title":"Python爬虫前准备","slug":"爬虫前准备","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:42:50.437Z","comments":true,"path":"2018/01/24/爬虫前准备/","link":"","permalink":"http://yoursite.com/2018/01/24/爬虫前准备/","excerpt":"","text":"首先说明一下我的爬虫环境是基于py2.x的， 为什么用这个版本呢，因为py2.x的版本支持的多，而且一般会使用py2.x环境，基本在py3.x也没有太大问题，好了，进入正题！ ###urllib 与 urllib2 urllib与urllib2是Python内置的，要实现Http请求，以urllib2为主,urllib为辅. 构建一个请求与响应模型 12345import urllib2strUrl = \"http://www.baidu.com\"response = urllib2.urlopen(strUrl)print response.read() 1234得到：&lt;div class=&quot;s_tab&quot; id=&quot;s_tab&quot;&gt; &lt;b&gt;网页&lt;/b&gt;&lt;a href=&quot;http://news.baidu.com/ns?cl=2&amp;rn=20&amp;tn=news&amp;word=&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;news&apos;&#125;)&quot;&gt;新闻&lt;/a&gt;&lt;a href=&quot;http://tieba.baidu.com/f?kw=&amp;fr=wwwt&quot; wdfield=&quot;kw&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;tieba&apos;&#125;)&quot;&gt;贴吧&lt;/a&gt;&lt;a href=&quot;http://zhidao.baidu.com/q?ct=17&amp;pn=0&amp;tn=ikaslist&amp;rn=10&amp;word=&amp;fr=wwwt&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;zhidao&apos;&#125;)&quot;&gt;知道&lt;/a&gt;&lt;a href=&quot;http://music.baidu.com/search?fr=ps&amp;ie=utf-8&amp;key=&quot; wdfield=&quot;key&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;music&apos;&#125;)&quot;&gt;音乐&lt;/a&gt;&lt;a href=&quot;http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;pic&apos;&#125;)&quot;&gt;图片&lt;/a&gt;&lt;a href=&quot;http://v.baidu.com/v?ct=301989888&amp;rn=20&amp;pn=0&amp;db=0&amp;s=25&amp;ie=utf-8&amp;word=&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;video&apos;&#125;)&quot;&gt;视频&lt;/a&gt;&lt;a href=&quot;http://map.baidu.com/m?word=&amp;fr=ps01000&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;map&apos;&#125;)&quot;&gt;地图&lt;/a&gt;&lt;a href=&quot;http://wenku.baidu.com/search?word=&amp;lm=0&amp;od=0&amp;ie=utf-8&quot; wdfield=&quot;word&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;wenku&apos;&#125;)&quot;&gt;文库&lt;/a&gt;&lt;a href=&quot;//www.baidu.com/more/&quot; onmousedown=&quot;return c(&#123;&apos;fm&apos;:&apos;tab&apos;,&apos;tab&apos;:&apos;more&apos;&#125;)&quot;&gt;更多»&lt;/a&gt;&lt;/div&gt; 这样就获取了整个网页内容.说明urlopen(strUrl,data,timeout) 第一个参数URL必传的，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间，后面两个参数不是必传的. Get与Post传送数据post与get传送数据是两个比较常用的数据传送方式，一般只需要掌握这两种方式就可以了. Get方式传送数据 123456789101112131415import urllib2import urllibvalues = &#123;&#125;values['username'] = '136xxxx0839'values['password'] = '123xxx'data = urllib.urlencode(values)#这里注意转换格式url = 'https://accounts.douban.com/login?alias=&amp;redir=https%3A%2F%2Fwww.douban.com%2F&amp;source=index_nav&amp;error=1001'getUrl = url+'?'+datarequest = urllib2.Request(getUrl)response = urllib2.urlopen(request)# print response.read()print getUrl得到：https://accounts.douban.com/login?alias=&amp;redir=https%3A%2F%2Fwww.douban.com%2F&amp;source=index_nav&amp;error=1001?username=136xxxx0839&amp;password=123xxx post数据传送方式 12345678values = &#123;&#125;values['username'] = '136xxxx0839'values['password'] = '123xxx'data = urllib.urlencode(values)url = 'https://accounts.douban.com/login?alias=&amp;redir=https%3A%2F%2Fwww.douban.com%2F&amp;source=index_nav&amp;error=1001'request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 两种请求方式差异点：post与request方式的数据传输时注意urllib2.Request(url,data)这里面的数据传输 注意处理请求的headers很多时候我们服务器会检验请求是否来自于浏览器，所以我们需要在请求的头部伪装成浏览器来请求服务器.一般做请求的时候，最好都要伪装成浏览器，防止出现拒绝访问等错误，这也是一种反爬虫的一种策略 123456user_agent = &#123;'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400 QQBrowser/9.7.12661.400'&#125;header = &#123;'User-Agent':user_agent&#125;url = 'http://www.qq.com/'request = urllib2.Request(url,headers=header)response = urllib2.urlopen(request)print response.read().decode('gbk')#这里注意一下需要对读取的网页内容进行转码，先要查看一下网页的chatset是什么格式. 在浏览器上打开www.qq.com然后按F12，查看User-Agent: User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用application/json ： 在 JSON RPC 调用时使用application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务 ###requestsrequests是Python最为常用的http请求库，也是极其简单的.使用的时候，首先需要对requests进行安装，直接使用Pycharm进行一键安装。 #####1.响应与编码 123456789101112131415import requestsurl = 'http://www.baidu.com'r = requests.get(url)print type(r)print r.status_codeprint r.encoding#print r.contentprint r.cookies得到：&lt;class 'requests.models.Response'&gt;200ISO-8859-1&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt; #####2.Get请求方式 123456values = &#123;'user':'aaa','id':'123'&#125;url = 'http://www.baidu.com'r = requests.get(url,values)print r.url得到：http://www.baidu.com/?user=aaa&amp;id=123 #####3.Post请求方式 123456789values = &#123;'user':'aaa','id':'123'&#125;url = 'http://www.baidu.com'r = requests.post(url,values)print r.url#print r.text得到：http://www.baidu.com/ #####4.请求头headers处理123456user_agent = &#123;'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400 QQBrowser/9.7.12661.400'&#125;header = &#123;'User-Agent':user_agent&#125;url = 'http://www.baidu.com/'r = requests.get(url,headers=header)print r.content #####5.响应码code与响应头headers处理 1234567891011121314url = 'http://www.baidu.com'r = requests.get(url)if r.status_code == requests.codes.ok: print r.status_code print r.headers print r.headers.get('content-type')#推荐用这种get方式获取头部字段else: r.raise_for_status() 得到：200&#123;'Content-Encoding': 'gzip', 'Transfer-Encoding': 'chunked', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Server': 'bfe/1.0.8.18', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:57 GMT', 'Connection': 'Keep-Alive', 'Pragma': 'no-cache', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Date': 'Wed, 17 Jan 2018 07:21:21 GMT', 'Content-Type': 'text/html'&#125;text/html #####6.cookie处理 123456789url = 'https://www.zhihu.com/'r = requests.get(url)print r.cookiesprint r.cookies.keys()得到：&lt;RequestsCookieJar[&lt;Cookie aliyungf_tc=AQAAACYMglZy2QsAEnaG2yYR0vrtlxfz for www.zhihu.com/&gt;]&gt;['aliyungf_tc'] #####7重定向与历史消息 处理重定向只是需要设置一下allow_redirects字段即可，将allow_redirectsy设置为True则是允许重定向的，设置为False则禁止重定向的 123456789r = requests.get(url,allow_redirects = True)print r.urlprint r.status_codeprint r.history得到：http://www.baidu.com/200[] #####8.超时设置 超时选项是通过参数timeout来设置的 12url = 'http://www.baidu.com'r = requests.get(url,timeout = 2) #####9.代理设置 123456789proxis = &#123; 'http':'http://www.baidu.com', 'http':'http://www.qq.com', 'http':'http://www.sohu.com',&#125;url = 'http://www.baidu.com'r = requests.get(url,proxies = proxis)","categories":[],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python爬虫/"}]},{"title":"Python爬虫把爬取到的数据存储到excel中","slug":"把爬取的数据存储到execl中","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:41:58.485Z","comments":true,"path":"2018/01/24/把爬取的数据存储到execl中/","link":"","permalink":"http://yoursite.com/2018/01/24/把爬取的数据存储到execl中/","excerpt":"","text":"操作Execl其实里面很多东西要去了解，但这里我讲常用的读写，满足我们的一般需求,感兴趣的朋友可以自己去深入。 ###1. 读execl文件需要安装 xlrd库，老办法，直接在setting中安装，然后导入放可使用python读取execl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# coding=utf-8import xlrddata = xlrd.open_workbook('execl_file.xlsx')table = data.sheets()[0] #通过索引顺序获取table, 一个execl文件一般都至少有一个tableprint table.nrows #行数print table.ncols #列数for k in range(table.nrows): #遍历行数据 print table.row_values(k)for i in range(table.ncols): #便利列数据 print table.col_values(i)print table.cell(2,2).value #获取单元格数据，前一个是行数，从0开始，后一个是列数，且列数从0开始for a in range(1,table.nrows): #行数据，我正好要去掉第1行标题 for b in range(table.ncols): print table.cell(a,b).value print '----------------------'得到结果：64[u'\\u54c1\\u724c', u'size', u'\\u4ef7\\u683c', u'\\u6027\\u522b'][u'Nike', 90.0, 1033.0, u'\\u7537'][u'addida', 88.0, 444.0, u'\\u5973'][u'zara', 87.0, 333.0, u'\\u7537'][u'Lining', 33.0, 22.0, u'\\u7537'][u'kappa', 33.0, 222.0, u'\\u7537'][u'\\u54c1\\u724c', u'Nike', u'addida', u'zara', u'Lining', u'kappa'][u'size', 90.0, 88.0, 87.0, 33.0, 33.0][u'\\u4ef7\\u683c', 1033.0, 444.0, 333.0, 22.0, 222.0][u'\\u6027\\u522b', u'\\u7537', u'\\u5973', u'\\u7537', u'\\u7537', u'\\u7537']444.0Nike90.01033.0男----------------------addida88.0444.0女----------------------zara87.0333.0男----------------------Lining33.022.0男----------------------kappa33.0222.0男---------------------- 很简单没有什么要解释的了 2. 复习一下range函数123456# &gt;&gt;&gt; range(1,5) #代表从1到5(不包含5)# [1, 2, 3, 4]# &gt;&gt;&gt; range(1,5,2) #代表从1到5，间隔2(不包含5)# [1, 3]# &gt;&gt;&gt; range(5) #代表从0到5(不包含5)# [0, 1, 2, 3, 4] 3. 写入execl需要安装xlwt库，老办法自己先安装，不多说了,需要导入xlwt然后放可使用python写入数据 1234workbook = xlwt.Workbook(encoding='utf-8')#创建workbook 其实就是execl，worksheet = workbook.add_sheet('my_worksheet') #创建表，如果想创建多个，直接在后面再add_sheetworksheet.write(0,0,label ='Row 0,Column 0 Value') #3个参数，第一个参数表示行，从0开始，第二个参数表示列从0开始，第三个参数表示插入的数值 workbook.save('execl_liu.xlsx') #写完记得一定要保存 完整实例代码 12345678910111213141516171819202122232425262728293031f = xlwt.Workbook() #创建工作薄#创建个人信息表sheet1 = f.add_sheet(u'个人信息',cell_overwrite_ok=True)rowTitle = [u'编号',u'姓名',u'性别',u'年龄']rowDatas = [[u'张一',u'男',u'18'],[u'李二',u'女',u'20'],[u'黄三',u'男',u'38'],[u'刘四',u'男',u'88']]for i in range(0,len(rowTitle)): sheet1.write(0,i,rowTitle[i],set_style('Times new Roman',220,True)) 后面是设置样式for k in range(0,len(rowDatas)): #先遍历外层的集合，即每行数据 rowDatas[k].insert(0,k+1) #每一行数据插上编号即为每一个人插上编号 for j in range(0,len(rowDatas[k])): #再遍历内层集合 sheet1.write(k+1,j,rowDatas[k][j]) #写入数据,k+1表示先去掉标题行，另外每一行数据也会变化,j正好表示第一列数据的变化，rowdatas[k][j] 插入数据#创建个人收入表sheet1 = f.add_sheet(u'个人收入表',cell_overwrite_ok=True)rowTitle2 = [u'编号',u'姓名',u'学历',u'工资']rowDatas2 = [[u'张一',u'本科',u'8000'],[u'李二',u'硕士',u'10000'],[u'黄三',u'博士',u'20000'],[u'刘四',u'教授',u'50000']]for i in range(0,len(rowTitle2)): sheet1.write(0,i,rowTitle2[i])for k in range(0,len(rowDatas2)): #先遍历外层的集合 rowDatas2[k].insert(0,k+1) #每一行数据插上编号即为每一个人插上编号 for j in range(0,len(rowDatas2[k])): #再遍历内层集合 sheet1.write(k+1,j,rowDatas2[k][j]) #写入数据,k+1表示先去掉标题行，另外每一行数据也会变化,j正好表示第一列数据的变化，rowdatas[k][j] 插入数据f.save('info.xlsx') 最后得到的效果图 3. 把爬取的猪八戒数据插入到execl中这里直接上代码了，相关的注释都在代码里 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# coding=utf-8import requestsimport timeimport xlwtimport xlrdfrom lxml import etreeclass ZbjData(object): def __init__(self): self.f = xlwt.Workbook() #创建工作薄 self.sheet1 = self.f.add_sheet(u'任务列表',cell_overwrite_ok=True) self.rowsTitle = [u'编号',u'标题',u'简介',u'价格',u'截止时间',u'链接'] for i in range(0, len(self.rowsTitle)): self.sheet1.write(0, i, self.rowsTitle[i], self.set_style('Times new Roman', 220, True)) self.f.save('zbj.xlsx') def set_style(self,name, height, bold=False): style = xlwt.XFStyle() # 初始化样式 font = xlwt.Font() # 为样式创建字体 font.name = name font.bold = bold font.colour_index = 2 font.height = height style.font = font return style def getUrl(self): for i in range(33): url = 'http://task.zbj.com/t-ppsj/p&#123;&#125;s5.html'.format(i+1) self.spiderPage(url) def spiderPage(self,url): if url is None: return None try: data = xlrd.open_workbook('zbj.xlsx') table = data.sheets()[0] # 通过索引顺序获取table, 一个execl文件一般都至少有一个table rowCount = table.nrows #获取行数 ，下次从这一行开始 proxies = &#123; 'http': 'http://221.202.248.52:80', &#125; user_agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400' headers = &#123;'User-Agent': user_agent&#125; htmlText = requests.get(url, headers=headers,proxies=proxies).text selector = etree.HTML(htmlText) tds = selector.xpath('//*[@class=\"tab-switch tab-progress\"]/table/tr') m = 0 for td in tds: data = [] price = td.xpath('./td/p/em/text()') href = td.xpath('./td/p/a/@href') title = td.xpath('./td/p/a/text()') subTitle = td.xpath('./td/p/text()') deadline = td.xpath('./td/span/text()') price = price[0] if len(price)&gt;0 else '' # python的三目运算 :为真时的结果 if 判定条件 else 为假时的结果 title = title[0] if len(title)&gt;0 else '' href = href[0] if len(href)&gt;0 else '' subTitle = subTitle[0] if len(subTitle)&gt;0 else '' deadline = deadline[0] if len(deadline)&gt;0 else '' #拼装成一个集合 data.append(rowCount+m) #加个序号 data.append(title) data.append(subTitle) data.append(price) data.append(deadline) data.append(href) for i in range(len(data)): self.sheet1.write(rowCount+m,i,data[i]) #写入数据到execl中 m+=1 #记录行数增量 print m print price, title, href, subTitle, deadline except Exception,e: print '出错',e.message finally: self.f.save('zbj.xlsx')if '_main_': zbj = ZbjData() zbj.getUrl() 注意这里爬取数据的时候，有的代理ip还是被禁用了，所以获取数据有失败的情况，所以这里需要有异常处理.","categories":[],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python爬虫/"}]},{"title":"Python爬大量数据时防止IP被封","slug":"防止iP被封","date":"2018-01-24T07:37:05.000Z","updated":"2018-01-24T11:41:32.388Z","comments":true,"path":"2018/01/24/防止iP被封/","link":"","permalink":"http://yoursite.com/2018/01/24/防止iP被封/","excerpt":"","text":"继续老套路，这两天我爬取了猪八戒上的一些数据 网址是：http://task.zbj.com/t-ppsj/p1s5.html，可能是由于爬取的数据量有点多吧，结果我的IP被封了，需要自己手动来验证解封ip,但这显然阻止了我爬取更多的数据了。 下面是我写的爬取猪八戒的被封IP的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# coding=utf-8import requestsfrom lxml import etreedef getUrl(): for i in range(33): url = 'http://task.zbj.com/t-ppsj/p&#123;&#125;s5.html'.format(i+1) spiderPage(url)def spiderPage(url): if url is None: return None htmlText = requests.get(url).text selector = etree.HTML(htmlText) tds = selector.xpath('//*[@class=\"tab-switch tab-progress\"]/table/tr') try: for td in tds: price = td.xpath('./td/p/em/text()') href = td.xpath('./td/p/a/@href') title = td.xpath('./td/p/a/text()') subTitle = td.xpath('./td/p/text()') deadline = td.xpath('./td/span/text()') price = price[0] if len(price)&gt;0 else '' # python的三目运算 :为真时的结果 if 判定条件 else 为假时的结果 title = title[0] if len(title)&gt;0 else '' href = href[0] if len(href)&gt;0 else '' subTitle = subTitle[0] if len(subTitle)&gt;0 else '' deadline = deadline[0] if len(deadline)&gt;0 else '' print price,title,href,subTitle,deadline print '---------------------------------------------------------------------------------------' spiderDetail(href) except: print '出错'def spiderDetail(url): if url is None: return None try: htmlText = requests.get(url).text selector = etree.HTML(htmlText) aboutHref = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/div/p[1]/a/@href') price = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/div/p[1]/text()') title = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/h2/text()') contentDetail = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[2]/div/div[1]/div[1]/text()') publishDate = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[2]/div/div[1]/p/text()') aboutHref = aboutHref[0] if len(aboutHref) &gt; 0 else '' # python的三目运算 :为真时的结果 if 判定条件 else 为假时的结果 price = price[0] if len(price) &gt; 0 else '' title = title[0] if len(title) &gt; 0 else '' contentDetail = contentDetail[0] if len(contentDetail) &gt; 0 else '' publishDate = publishDate[0] if len(publishDate) &gt; 0 else '' print aboutHref,price,title,contentDetail,publishDate except: print '出错'if '_main_': getUrl() 我发现代码运行完后，后面有几页数据没有被爬取，我再也没有办法去访问猪八戒网站了，等过了一段时间才能去访问他们的网站，这就很尴尬了，我得防止被封IP 如何防止爬取数据的时候被网站封IP这里有一些套路.查了一些套路 1.修改请求头之前的爬虫代码没有添加头部，这里我添加了头部，模拟成浏览器去访问网站 1234user_agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400'headers = &#123;'User-Agent': user_agent&#125;htmlText = requests.get(url, headers=headers, proxies=proxies).text 2.采用代理IP当自己的ip被网站封了之后，只能采用代理ip的方式进行爬取，所以每次爬取的时候尽量用代理ip来爬取，封了代理还有代理。 这里我引用了这个博客的一段代码来生成ip地址:http://blog.csdn.net/lammonpeter/article/details/52917264 生成代理ip,大家可以直接把这个代码拿去用 1234567891011121314151617181920212223242526272829303132333435# coding=utf-8# IP地址取自国内髙匿代理IP网站：http://www.xicidaili.com/nn/# 仅仅爬取首页IP地址就足够一般使用from bs4 import BeautifulSoupimport requestsimport randomdef get_ip_list(url, headers): web_data = requests.get(url, headers=headers) soup = BeautifulSoup(web_data.text, 'lxml') ips = soup.find_all('tr') ip_list = [] for i in range(1, len(ips)): ip_info = ips[i] tds = ip_info.find_all('td') ip_list.append(tds[1].text + ':' + tds[2].text) return ip_listdef get_random_ip(ip_list): proxy_list = [] for ip in ip_list: proxy_list.append('http://' + ip) proxy_ip = random.choice(proxy_list) proxies = &#123;'http': proxy_ip&#125; return proxiesif __name__ == '__main__': url = 'http://www.xicidaili.com/nn/' headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36' &#125; ip_list = get_ip_list(url, headers=headers) proxies = get_random_ip(ip_list) print(proxies) 好了我用上面的代码给我生成了一批ip地址（有些ip地址可能无效，但只要不封我自己的ip就可以了,哈哈），然后我就可以在我的请求头部添加ip地址 给我们的请求添加代理ip 123456789proxies = &#123; 'http': 'http://124.72.109.183:8118', 'http': 'http://49.85.1.79:31666'&#125;user_agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400'headers = &#123;'User-Agent': user_agent&#125;htmlText = requests.get(url, headers=headers, timeout=3, proxies=proxies).text 目前知道的就 最后完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# coding=utf-8import requestsimport timefrom lxml import etreedef getUrl(): for i in range(33): url = 'http://task.zbj.com/t-ppsj/p&#123;&#125;s5.html'.format(i+1) spiderPage(url)def spiderPage(url): if url is None: return None try: proxies = &#123; 'http': 'http://221.202.248.52:80', &#125; user_agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4295.400' headers = &#123;'User-Agent': user_agent&#125; htmlText = requests.get(url, headers=headers,proxies=proxies).text selector = etree.HTML(htmlText) tds = selector.xpath('//*[@class=\"tab-switch tab-progress\"]/table/tr') for td in tds: price = td.xpath('./td/p/em/text()') href = td.xpath('./td/p/a/@href') title = td.xpath('./td/p/a/text()') subTitle = td.xpath('./td/p/text()') deadline = td.xpath('./td/span/text()') price = price[0] if len(price)&gt;0 else '' # python的三目运算 :为真时的结果 if 判定条件 else 为假时的结果 title = title[0] if len(title)&gt;0 else '' href = href[0] if len(href)&gt;0 else '' subTitle = subTitle[0] if len(subTitle)&gt;0 else '' deadline = deadline[0] if len(deadline)&gt;0 else '' print price,title,href,subTitle,deadline print '---------------------------------------------------------------------------------------' spiderDetail(href) except Exception,e: print '出错',e.messagedef spiderDetail(url): if url is None: return None try: htmlText = requests.get(url).text selector = etree.HTML(htmlText) aboutHref = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/div/p[1]/a/@href') price = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/div/p[1]/text()') title = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[1]/div/div/h2/text()') contentDetail = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[2]/div/div[1]/div[1]/text()') publishDate = selector.xpath('//*[@id=\"utopia_widget_10\"]/div[2]/div/div[1]/p/text()') aboutHref = aboutHref[0] if len(aboutHref) &gt; 0 else '' # python的三目运算 :为真时的结果 if 判定条件 else 为假时的结果 price = price[0] if len(price) &gt; 0 else '' title = title[0] if len(title) &gt; 0 else '' contentDetail = contentDetail[0] if len(contentDetail) &gt; 0 else '' publishDate = publishDate[0] if len(publishDate) &gt; 0 else '' print aboutHref,price,title,contentDetail,publishDate except: print '出错'if '_main_': getUrl() 最后程序完美运行，再也没有出现被封IP的情况。当然防止被封IP肯定不止这些了，这还需要进一步探索! ###最后当然数据我是已经抓取过来了，但是我的数据都没有完美呈现出来，我应该写入execl文件，或者数据库中啊，这样才能方便采用.所以接下来我准备了使用Python操作execl,mysql,mongoDB","categories":[],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python爬虫/"}]},{"title":"为什么要学习Python以及Python环境安装","slug":"为什么要学习Python以及Python环境安装","date":"2018-01-23T16:00:00.000Z","updated":"2018-01-24T11:42:37.203Z","comments":true,"path":"2018/01/24/为什么要学习Python以及Python环境安装/","link":"","permalink":"http://yoursite.com/2018/01/24/为什么要学习Python以及Python环境安装/","excerpt":"","text":"为什么要学习PythonPython十分强大，学习python理由我就列举如下几条: 可以做服务器后台 可以做自动化工具 可以网络爬取数据 可以做web网站 可以进行数据分析 可以人工智能研究 个人以前学的东西太杂了:Android(主),java,php,go,ios,前端。现在准备专挑一门语言进行深入。在Android行情没落的时候，在人工智能与大数据到来的时候，学习Python也许是一个不错的选择.从前端到后台，什么都能干。python在手，天下我有！ #对于新手来说是快速学习而不是折腾IDE,Pycharm集成了所有python需要用的插件，以及第三方库，一键安装一系列你需要的库像Numpy,Requests,MatplotLib等，让你快速开发不折腾与环境， ###选择Python IDE 一直以来对JetBranis公司开发的一些IDE情有独钟，虽然他们的IDE对电脑要求配置非常高，但不介意，像他们的IDE涵盖大部分主流开发环境并且也是最好的IDE.Android ,java,php,python,go,ios,前端，他们公司都有对应的IDE,而且他们的IDE工具都是一脉相承的，你会使用其中一个，那么其它的IDE基本也是相同的用法。 Python环境安装今天开发专注Python学习，所以jetbrains公司的Pycharm当然是我开发的首选工具了 Pytharm win版 下载地址 然后需要一个激活码，这里我选择一个server,输入地址http://idea.imsxm.com/ 即可激活. 然后启动IDE这里打开后会提示一个错误，说你没有选择python解释器 No Python interpreter selected 打开python官网，下载python解释器官网，这里我下载的是3.6版本的，虽然大多数成熟的库还是在用2.x版本，但既然是学习，肯定是要面向未来 ，所以我这里选择的是3.6版本 双击安装Python解释器文件。 安装完毕后，在IDE启动界面显示错误的地方，添加add local来选择解释器，然后点击Create 这样python环境搭建完毕 尼玛：太简单了，就忘了截图，其实搭建真的是非常简单，无图就无图吧。 最后上一句经典代码hello world效果图","categories":[],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python基础/"}]}]}